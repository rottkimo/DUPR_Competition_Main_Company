<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DUPR æ¯”è³½åˆ†æ•¸è¼¸å…¥ï¼ˆå¤šå ´åœ°ï¼‰</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>

    /* Team color theming for A/B columns */
    .teamA { background-color: #e8f1ff !important; border-color: #b6d4fe !important; }
    .teamB { background-color: #ffe8e8 !important; border-color: #f1b0b7 !important; }
    .teamA:disabled, .teamB:disabled { opacity: 0.95; }
    td.teamA-cell { background: linear-gradient(to right, rgba(13,110,253,0.06), transparent); }
    td.teamB-cell { background: linear-gradient(to left, rgba(220,53,69,0.06), transparent); }

    .locked-row { opacity: 0.75; }

    /* å°ˆæ³¨æª¢è¦–ç”¨å¤§å­—é«” */
    .focus-title { font-size: 1.75rem; font-weight: 700; }
    .focus-section { margin-top: 1rem; }
    .focus-label { font-size: 1.2rem; font-weight: 600; }
    .focus-select { font-size: 1.15rem; padding: .6rem .75rem; }
    .focus-score { width: 120px; font-size: 2rem; text-align: center; }
    .focus-team-label { font-size: 1.25rem; font-weight: 700; }

    body { padding: 2rem; }
    .table td, .table th { vertical-align: middle; }
    .score-input { width: 60px; text-align: center; }
    .btn-space { margin-right: 10px; margin-bottom: 5px; }
    #courtTabsContainer { margin-bottom: 1rem; }
  </style>
</head>
<body>

<!-- èªéŸ³è¨­å®šï¼ˆé›²ç«¯å¥³è²ï¼‰ -->
<div id="cloudVoiceSettings" class="card mt-2" style="max-width:860px;margin:12px auto;border:1px solid #e5e7eb;border-radius:12px;">
  <div class="card-body" style="padding:12px 16px;">
    <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
      <div style="font-weight:700;">èªéŸ³è¨­å®šï¼ˆé›²ç«¯å¥³è²ï¼‰</div>
      <label class="form-check-inline">
        <input class="form-check-input" type="checkbox" id="useCloudTTSChk_main">
        å•Ÿç”¨é›²ç«¯å¥³è²ï¼ˆå¤±æ•—æ™‚è‡ªå‹•æ”¹ç”¨æœ¬æ©Ÿï¼‰
      </label>
      <div style="display:flex;gap:8px;align-items:center;">
        <label class="form-label mb-0">è²éŸ³</label>
        <select id="cloudVoiceSelect" class="form-select form-select-sm" style="min-width:220px;">
          <option value="zh-TW-HsiaoChenNeural">HsiaoChenï¼ˆç¹ä¸­å¥³ï¼‰</option>
          <option value="zh-TW-HsiaoYuNeural">HsiaoYuï¼ˆç¹ä¸­å¥³ï¼‰</option>
          <option value="zh-TW-YunJheNeural">YunJheï¼ˆç¹ä¸­ç”·ï¼‰</option>
          <option value="zh-CN-XiaoxiaoNeural">Xiaoxiaoï¼ˆä¸­æ–‡å¥³ï¼‰</option>
          <option value="en-US-JennyNeural">Jennyï¼ˆè‹±æ–‡å¥³ï¼‰</option>
          <option value="en-US-AriaNeural">Ariaï¼ˆè‹±æ–‡å¥³ï¼‰</option>
        </select>
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <label class="form-label mb-0">èªé€Ÿ</label>
        <button id="rateMinusBtn" class="btn btn-sm btn-outline-secondary" type="button">-5%</button>
        <input id="cloudRateInput" class="form-control form-control-sm" style="width:90px" value="0%">
        <button id="ratePlusBtn" class="btn btn-sm btn-outline-secondary" type="button">+5%</button>>
      
<div style="font-size:12px;color:#6b7280;margin-top:4px;">
  èªé€Ÿèªªæ˜ï¼š<code>0%</code>=æ­£å¸¸ã€<code>-10%</code>=æ…¢ä¸€é»ã€<code>+10%</code>=å¿«ä¸€é»ï¼›ä¹Ÿå¯è¼¸å…¥ <code>0.95</code> è¡¨ç¤º 95%ï¼ˆæœƒè‡ªå‹•è½‰æˆ <code>-5%</code>ï¼‰ã€‚
</div>

      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <label class="form-label mb-0">éŸ³é«˜</label>
        <input id="cloudPitchInput" class="form-control form-control-sm" style="width:90px" value="+6%">
      </div>
      <button id="cloudSaveBtn" class="btn btn-sm btn-outline-secondary" type="button">ä¿å­˜</button>
    </div>
  </div>

<!-- TTS ç‹€æ…‹é¡¯ç¤º -->
  <div style="display:flex;gap:8px;align-items:center;">
    <label class="form-label mb-0">ä¼ºæœå™¨</label>
    <input id="cloudServerInput" class="form-control form-control-sm" style="min-width:260px" placeholder="http://localhost:8787/api/tts">
    <button id="cloudPingBtn" class="btn btn-sm btn-outline-primary" type="button">Cloud æ¸¬è©¦</button>
    <label class="form-check-inline" title="åµéŒ¯ç”¨ï¼šåªç”¨é›²ç«¯ï¼Œå¤±æ•—å°±ä¸æ’­ï¼Œé¿å…è‡ªå‹•é€€å›æœ¬æ©Ÿé€ æˆèª¤åˆ¤">
      <input class="form-check-input" type="checkbox" id="cloudOnlyChk">
      é›²ç«¯åƒ…ç”¨ï¼ˆå¤±æ•—ä¸æ’­ï¼‰
    </label>
  </div>
  <div id="cloudDiag" style="margin-top:6px;font-size:12px;color:#444;background:#f9fafb;border:1px solid #eee;border-radius:8px;padding:8px;display:none;"></div>

<div id="ttsStatusBar" style="max-width:860px;margin:0 auto;padding:4px 0 0 0;">
  <span id="ttsStatusBadge" style="display:inline-block;padding:4px 10px;border-radius:999px;background:#e5e7eb;color:#111;font-size:12px;font-weight:600;">TTS: æº–å‚™ä¸­â€¦</span>
</div>

</div>

  <div class="container">
    <!-- å ´åœ°åˆ‡æ›æŒ‰éˆ• -->
    <div id="courtTabsContainer" class="text-center"></div>
<div class="text-center mb-2">
  <button class="btn btn-outline-secondary btn-sm" data-bs-toggle="modal" data-bs-target="#ttsSettingsModal">ğŸ”Š èªéŸ³è¨­å®š</button>
</div>

    <h2 class="text-center text-primary">Organizer: Rott</h2>

    <div class="text-center mb-3">
      <button class="btn btn-light btn-space" onclick="window.open('input_player_data_v4.html', '_blank')">é¸æ‰‹è³‡æ–™<br>(Players)</button>
      <button class="btn btn-dark btn-space">æ¯”è³½åˆ†æ•¸<br>(Matches)</button>
    </div>

    <table class="table table-bordered">
      <thead class="table-light">
        <tr class="${m.locked?'locked-row':''}">
          <th></th>
          <th>#</th>
          <th>A1</th><th>A2</th><th>B1</th><th>B2</th>
          <th>S/D</th>
          <th>A Score</th><th>B Score</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody id="matchTableBody"></tbody>
    </table>

    <div class="row mb-3">
      <div class="col-md-4">
        <label for="locationInput" class="form-label">æ¯”è³½åœ°é»</label>
        <div class="input-group">
          <select id="locationInput" class="form-select" data-default="New Taipei Pickleball Association NTCPAæ–°åŒ—å¸‚åŒ¹å…‹çƒå”æœƒç©ç©—DUPR"></select>
          <button class="btn btn-outline-secondary" type="button" onclick="addLocation()">å¢åŠ åœ°é»</button>
          <button class="btn btn-outline-dark" type="button" data-bs-toggle="modal" data-bs-target="#locationsManagerModal">åœ°é»ç®¡ç†</button>
          <button class="btn btn-outline-primary" type="button" id="loginBtn" onclick="signInWithGoogle()">ç™»å…¥ Google</button>
          <button class="btn btn-outline-secondary d-none" type="button" id="logoutBtn" onclick="signOutFirebase()">ç™»å‡º</button>
          <button class="btn btn-outline-info" type="button" id="cfgBtn" onclick="promptFirebaseConfig()">Firebase è¨­å®š</button>
        </div>
      
        <div class="form-text" id="authStatus">æœªç™»å…¥ï¼šç›®å‰åƒ…ä¿å­˜åœ¨æ­¤è£ç½®</div>
      </div>
      <div class="col-md-4">
        <label for="dateInput" class="form-label">æ¯”è³½æ—¥æœŸ</label>
        <input type="date" id="dateInput" class="form-control" >
      </div>
      <div class="col-md-4">
        <label for="unlockPassword" class="form-label">ğŸ”‘ è§£é–å¯†ç¢¼</label>
        <div class="input-group">
  <input type="password" id="unlockPassword" class="form-control w-auto">
  <button class="btn btn-outline-danger" type="button" onclick="deleteAllMatches()" title="ä¸€æ¬¡åˆªé™¤ç›®å‰å ´åœ°æ‰€æœ‰å ´æ¬¡è³‡æ–™">ä¸€éµåˆªé™¤</button>
</div>
      </div>
    </div>

    <div class="mb-3">
      <button class="btn btn-success btn-space" onclick="addMatch()">ï¼‹ æ·»åŠ æ¯”è³½<br>(Add Match)</button>
      <input type="file" id="importCSVInput" accept=".csv" style="display: none" onchange="importCSV(event)">
      <button class="btn btn-info btn-space" onclick="document.getElementById('importCSVInput').click()">â¬† åŒ¯å…¥æ¯”è³½è³‡æ–™</button>
      <button class="btn btn-warning btn-space" onclick="exportCSV()">â¬‡ åŒ¯å‡º CSV</button>
      <button class="btn btn-outline-warning btn-space" onclick="exportDUPRCSV()">â¬‡ åŒ¯å‡ºDUPRä¸Šå‚³ç”¨CSV</button>
    
    <!-- å…¨åŸŸé™„åŠ æ’­å ±è³‡è¨Šï¼ˆä¸»ç•«é¢å¯ç›´æ¥ç·¨è¼¯ï¼›æœ‰å…§å®¹å°±æœƒåœ¨çµå°¾èªä¹‹å‰æ’­å ±ï¼‰ -->
    <div class="row mb-3">
      <div class="col-12">
        <label for="ttsExtraTextGlobal" class="form-label">æ¯”è³½è¦å‰‡é™„åŠ è³‡è¨Š</label>
        <input id="ttsExtraTextGlobal" type="text" class="form-control" placeholder="ä¾‹å¦‚ï¼šæ¯”è³½æ¡ 11 åˆ†åˆ¶ï¼ŒNo deuceï¼Œç™¼çƒå¾—åˆ†åˆ¶ã€‚">

<!-- é™„åŠ è³‡è¨Šç¯„æœ¬ç®¡ç† -->
<div class="row g-2 align-items-center mt-1">
  <div class="col-12 col-md-6">
    <select id="ttsExtraTemplateSelect" class="form-select form-select-sm" aria-label="é™„åŠ è³‡è¨Šç¯„æœ¬æ¸…å–®"></select>
  </div>
  <div class="col-12 col-md-6 d-flex gap-2">
    <button class="btn btn-sm btn-outline-secondary" id="extraTplApplyBtn" title="å°‡é¸å–ç¯„æœ¬å¥—ç”¨åˆ°è¼¸å…¥æ¡†">å¥—ç”¨</button>
    <button class="btn btn-sm btn-outline-primary" id="extraTplSaveBtn" title="æŠŠç›®å‰è¼¸å…¥å…§å®¹å„²å­˜ç‚ºæ–°ç¯„æœ¬">å„²å­˜</button>
    <button class="btn btn-sm btn-outline-success" id="extraTplUpdateBtn" title="ä»¥ç›®å‰è¼¸å…¥è¦†è“‹æ‰€é¸ç¯„æœ¬">æ›´æ–°</button>
    <button class="btn btn-sm btn-outline-danger" id="extraTplDeleteBtn" title="åˆªé™¤æ‰€é¸ç¯„æœ¬">åˆªé™¤</button>
  </div>
</div>

      </div>
    </div>
</div>

    <div class="alert alert-warning text-center">
      æ´›ç‰¹ç©¿ç·šå·¥ä½œå®¤ ğŸ‘‰ <a href="https://www.facebook.com/RottStringingStudio/" target="_blank">é»æˆ‘äº†è§£</a>
    </div>
  </div>

  <script>
    const COURT_COUNT = 4;
    let currentCourt = 1;
    let matchData = [];
    const validHashes = [
      "2cec8cf0e321c284fa0c2ebef804aac18bf1cbb85546f89e7e3d0b6aa8b9d2cf",
      "f457528f5880e850a162d62a3db51dda0f8c339434dd424b9781570aab5d4abb"
    ];

    function loadMatchData() {
      const raw = localStorage.getItem('dupr_matches_court_' + currentCourt);
      try { matchData = JSON.parse(raw) || []; } catch { matchData = []; }
    }

    function saveMatchData() {
      localStorage.setItem('dupr_matches_court_' + currentCourt, JSON.stringify(matchData));
    }

    function getPlayers() {
      const raw = localStorage.getItem('players');
      try { return JSON.parse(raw) || []; } catch { return []; }
    }

    function initCourtTabs() {
      const container = document.getElementById('courtTabsContainer');
      container.innerHTML = '';
      for (let i = 1; i <= COURT_COUNT; i++) {
        const name = localStorage.getItem('courtName_' + i) || (i + 'è™Ÿå ´åœ°');
        const btn = document.createElement('button');
        btn.id = 'courtTab' + i;
        btn.className = 'btn btn-outline-secondary btn-space';
        btn.textContent = name;
        btn.addEventListener('click', () => switchCourt(i));
        btn.addEventListener('dblclick', () => renameCourt(i));
        container.appendChild(btn);
      }
    }

    function renameCourt(i) {
      const old = localStorage.getItem('courtName_' + i) || (i + 'è™Ÿå ´åœ°');
      const name = prompt('è«‹è¼¸å…¥æ–°çš„å ´åœ°åç¨±ï¼š', old);
      if (name) {
        localStorage.setItem('courtName_' + i, name);
        document.getElementById('courtTab' + i).textContent = name;
      }
    }

    function switchCourt(i) {
      currentCourt = i;
      initTabStyles();
      loadMatchData();
      renderTable();
    }

    function initTabStyles() {
      for (let i = 1; i <= COURT_COUNT; i++) {
        const btn = document.getElementById('courtTab' + i);
        btn.classList.toggle('btn-primary', i === currentCourt);
        btn.classList.toggle('btn-outline-secondary', i !== currentCourt);
      }
    }

    function createPlayerOptions(selected = '') {
      const list = getPlayers();
      let opts = '<option value="">--</option>';
      list.forEach(p => {
        opts += `<option value="${p.name}" ${p.name === selected ? 'selected' : ''}>${p.name}</option>`;
      });
      return opts;
    }

    // ä¾å ´æ¬¡åˆ—å‹•æ…‹éæ¿¾ï¼ˆé¿å… A1/A2/B1/B2 é‡è¤‡ï¼‰
    function createPlayerOptionsFiltered(idx, field, selected = '') {
      const list = getPlayers();
      const m = matchData[idx] || {};
      const used = new Set();
      if (field !== 'A1' && m.A1) used.add(m.A1);
      if (field !== 'A2' && m.A2) used.add(m.A2);
      if (field !== 'B1' && m.B1) used.add(m.B1);
      if (field !== 'B2' && m.B2) used.add(m.B2);
      let opts = '<option value="">--</option>';
      list.forEach(p => {
        const name = p.name;
        if (name === selected) {
          opts += `<option value="${name}" selected>${name}</option>`;
        } else if (!used.has(name)) {
          opts += `<option value="${name}">${name}</option>`;
        }
      });
      return opts;
    }

    // ä¿è­‰åŒä¸€å ´æ¬¡ 4 å€‹æ¬„ä½ä¸é‡è¤‡ï¼›å¦‚é‡è¤‡å‰‡è‡ªå‹•æ¸…ç©ºå¾Œè€…
    function enforceUniqueInRow(idx) {
      const m = matchData[idx] || {};
      const fields = ['A1','A2','B1','B2'];
      const seen = new Set();
      fields.forEach(f => {
        const v = (m[f] || '').trim();
        if (!v) return;
        if (seen.has(v)) {
          m[f] = '';
        } else {
          seen.add(v);
        }
      });
    }

    function renderTable() {
      saveMatchData();
      const tbody = document.getElementById('matchTableBody');
      tbody.innerHTML = '';
      matchData.forEach((m, idx) => {
        tbody.innerHTML += `
          <tr class="${m.locked?'locked-row':''}">
            <td class="text-center">${m.locked ? "" : `<button class="btn btn-outline-primary btn-sm" title="å°ˆæ³¨æª¢è¦–" onclick="focusMatch(${idx})">ğŸ”</button>`}</td>
            <td><button class="btn btn-link p-0 text-decoration-none" title="èªéŸ³æ’­å ±æ­¤å ´æ¬¡" onclick="announceMatch(${idx})">${idx+1}</button></td>
            <td class="teamA-cell"><select id="A1_${idx}" class="form-select teamA" ${m.locked?'disabled':''} onchange="updateField(${idx}, 'A1', this.value)">${createPlayerOptionsFiltered(idx, 'A1', m.A1)}</select></td>
            <td class="teamA-cell"><select id="A2_${idx}" class="form-select teamA" ${m.locked?'disabled':''} onchange="updateField(${idx}, 'A2', this.value)">${createPlayerOptionsFiltered(idx, 'A2', m.A2)}</select></td>
            <td class="teamB-cell"><select id="B1_${idx}" class="form-select teamB" ${m.locked?'disabled':''} onchange="updateField(${idx}, 'B1', this.value)">${createPlayerOptionsFiltered(idx, 'B1', m.B1)}</select></td>
            <td class="teamB-cell"><select id="B2_${idx}" class="form-select teamB" ${m.locked?'disabled':''} onchange="updateField(${idx}, 'B2', this.value)">${createPlayerOptionsFiltered(idx, 'B2', m.B2)}</select></td>
            <td><select id="SD_${idx}" class="form-select" ${m.locked?'disabled':''} onchange="updateSD(${idx}, this.value)">
              <option value="S" ${m.SD==='S'?'selected':''}>S</option>
              <option value="D" ${m.SD==='D'?'selected':''}>D</option>
            </select></td>
            <td><input type="number" class="form-control score-input" ${m.locked?'disabled':''} value="${m.AScore||''}" onchange="updateField(${idx}, 'AScore', this.value)"></td>
            <td><input type="number" class="form-control score-input" ${m.locked?'disabled':''} value="${m.BScore||''}" onchange="updateField(${idx}, 'BScore', this.value)"></td>
            <td class="text-center">
              <button class="btn btn-${m.locked? 'success':'outline-success'} btn-sm me-1" onclick="toggleLock(${idx})">${m.locked?'ğŸ”’':'ğŸ”“'}</button>
              <button class="btn btn-danger btn-sm" onclick="confirmDelete(${idx})">ğŸ—‘ï¸</button>
            </td>
          </tr>`;
      });
      // ä¾ç…§ S/D ç‹€æ…‹å•Ÿç”¨/åœç”¨ A2, B2
      matchData.forEach((m, idx) => applySDRules(idx, m.SD));
    }

    function updateField(idx, field, value) {
      matchData[idx][field] = value;
      enforceUniqueInRow(idx);
      saveMatchData();
      renderTable();
    }

    function updateSD(idx, value) {
      matchData[idx].SD = value;
      if (value === 'S') {
        matchData[idx].A2 = '';
        matchData[idx].B2 = '';
      }
      saveMatchData();
      applySDRules(idx, value);
    }

    function applySDRules(idx, sd) {
      const a2 = document.getElementById(`A2_${idx}`);
      const b2 = document.getElementById(`B2_${idx}`);
      if (!a2 || !b2) return;
      // å¦‚è©²å ´å·²é–å®šï¼Œæ•´è¡Œéƒ½ä¸å¯ç·¨è¼¯
      if (matchData[idx] && matchData[idx].locked) {
        a2.disabled = true;
        b2.disabled = true;
        return;
      }
      if (sd === 'S') {
        a2.disabled = true; a2.value = '';
        b2.disabled = true; b2.value = '';
      } else {
        a2.disabled = false;
        b2.disabled = false;
      }
    }

    function addMatch() {
      matchData.push({A1:'',A2:'',B1:'',B2:'',SD:'D',AScore:'',BScore:'',locked:false});
      renderTable();
    }

    function importCSV(e) {
      const file = e.target.files[0]; if(!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        const lines = ev.target.result.split('\n').filter(l=>l.trim());
        matchData = lines.map(l=>{
          const c = l.replace(/"/g,'').split(',');
          return { A1:c[6]||'', A2:c[9]||'', B1:c[12]||'', B2:c[15]||'', SD:c[3]||'D', AScore:c[19]||'', BScore:c[20]||'', locked:false };
        });
        renderTable();
      };
      reader.readAsText(file,'utf-8');
    }

    
function downloadCSV(filename, csvContent) {
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  const canShareFiles = navigator.canShare && navigator.canShare({ files: [new File([blob], filename, { type: 'text/csv' })] });

  function fallbackDownload() {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;

    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (isSafari && isIOS) {
      // æç¤ºé•·æŒ‰å„²å­˜
      showTemporaryMessage(`
        <div class="alert alert-info">
          ç„¡æ³•è‡ªå‹•ä¸‹è¼‰ï¼Ÿè«‹é•·æŒ‰ä¸‹é¢é€£çµé¸ã€Œå„²å­˜åˆ°æª”æ¡ˆã€æˆ–ç”¨åˆ†äº«åŠŸèƒ½ï¼š<br/>
          <a href="${url}" download="${filename}">é»æ­¤ä¸‹è¼‰ ${filename}</a>
        </div>
      `, 10000);
    } else {
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
    setTimeout(() => URL.revokeObjectURL(url), 1000 * 10);
  }

  if (isIOS && canShareFiles) {
    const file = new File([blob], filename, { type: 'text/csv' });
    navigator.share({
      files: [file],
      title: filename,
      text: 'é€™æ˜¯ä½ çš„ CSV åŒ¯å‡ºæª”æ¡ˆ',
    }).catch((err) => {
      console.warn('åˆ†äº«å¤±æ•—ï¼Œé€€å›åˆ°ä¸‹è¼‰ï¼é¡¯ç¤º fallbackï¼š', err);
      fallbackDownload();
    });
  } else {
    fallbackDownload();
  }
}

function showTemporaryMessage(htmlContent, duration=5000) {
  const wrapper=document.createElement('div');
  wrapper.innerHTML=htmlContent;
  wrapper.style.position='fixed';
  wrapper.style.top='10px';
  wrapper.style.left='50%';
  wrapper.style.transform='translateX(-50%)';
  wrapper.style.zIndex=9999;
  document.body.appendChild(wrapper);
  setTimeout(()=>{ document.body.removeChild(wrapper); }, duration);
}

function exportCSV() {
      const players = getPlayers();
      const getId = n=>{ const f=players.find(p=>p.name===n); return f?f.duprId:''; };
      const loc = document.getElementById('locationInput').value;
      const dt  = document.getElementById('dateInput').value;
      let csv="";
      matchData.forEach(r=>{
        csv += [
          '', '', '', r.SD||'D', loc, dt,
          r.A1, getId(r.A1),'', r.A2,getId(r.A2),'', r.B1,getId(r.B1),'', r.B2,getId(r.B2),'', '', r.AScore||'', r.BScore||''
        ].map(f=>`"${f}"`).join(',')+"\n";
      });
      const headered = "\uFEFF" + csv; // BOM for Excel
      downloadCSV('dupr_scores.csv', headered);
}

function exportDUPRCSV() {
      const players = getPlayers();
      const getId = n=>{ const f=players.find(p=>p.name===n); return f?f.duprId:''; };
      const loc = document.getElementById('locationInput').value;
      const dt  = document.getElementById('dateInput').value;
      let csv="";
      matchData.forEach(r=>{
        csv += [
          '', '', '', r.SD||'D', loc, dt,
          r.A1, getId(r.A1),'', r.A2,getId(r.A2),'', r.B1,getId(r.B1),'', r.B2,getId(r.B2),'', '', r.AScore||'', r.BScore||''
        ].map(f=>`"${f}"`).join(',')+"\n";
      });
      // ç´” UTF-8 ç„¡ BOMï¼Œé¿å…æŸäº›å¾Œå°ä¸æ¥å— BOM
      downloadCSV('dupr_upload_utf8.csv', csv);
}

async function toggleLock(i) {
      if(!matchData[i].locked) {
        matchData[i].locked = true; renderTable();
      } else {
        const pwd = document.getElementById('unlockPassword').value.trim(); if(!pwd) return alert('è«‹å…ˆè¼¸å…¥å¯†ç¢¼ï¼');
        const h = await hashString(pwd);
        if(validHashes.includes(h)) { matchData[i].locked = false; renderTable(); }
        else alert('å¯†ç¢¼éŒ¯èª¤ç„¡æ³•è§£é–');
      }
    }

    async function confirmDelete(i) {
      if(!matchData[i].locked) {
        if(confirm('ç¢ºå®šåˆªé™¤ï¼Ÿ')) matchData.splice(i,1), renderTable();
      } else {
        const pwd = prompt('å·²é–å®šï¼Œè«‹è¼¸å…¥å¯†ç¢¼ï¼š'); if(!pwd) return;
        const h = await hashString(pwd);
        if(validHashes.includes(h) && confirm('å¯†ç¢¼æ­£ç¢ºï¼Œç¢ºå®šåˆªé™¤ï¼Ÿ')) { matchData.splice(i,1); renderTable(); }
        else alert('å¯†ç¢¼éŒ¯èª¤');
      }
    }

    async function hashString(s) {
      const buf = new TextEncoder().encode(s);
      const hash = await crypto.subtle.digest('SHA-256', buf);
      return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    
async function deleteAllMatches(){
  try {
    const total = (matchData || []).length;
    if (!total) { alert('ç›®å‰æ²’æœ‰ä»»ä½•å ´æ¬¡å¯åˆªé™¤ã€‚'); return; }
    const hasLocked = (matchData || []).some(m => m && m.locked);
    let pwd = null;
    if (hasLocked) {
      pwd = await new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.background = 'rgba(0,0,0,0.5)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.innerHTML = `
          <div style="background:#fff;padding:20px;border-radius:8px;max-width:300px;width:100%;">
            <p>åµæ¸¬åˆ°æœ‰é–å®šçš„å ´æ¬¡ï¼Œè«‹è¼¸å…¥è§£é–å¯†ç¢¼ä»¥åˆªé™¤å…¨éƒ¨ï¼š</p>
            <input type="password" id="deleteAllPwdInput" style="width:100%;padding:6px;margin-bottom:10px;">
            <div style="text-align:right;">
              <button id="deleteAllCancelBtn">å–æ¶ˆ</button>
              <button id="deleteAllOkBtn">ç¢ºå®š</button>
            </div>
          </div>`;
        document.body.appendChild(modal);
        modal.querySelector('#deleteAllCancelBtn').onclick = () => {
          document.body.removeChild(modal);
          resolve(null);
        };
        modal.querySelector('#deleteAllOkBtn').onclick = () => {
          const val = modal.querySelector('#deleteAllPwdInput').value;
          document.body.removeChild(modal);
          resolve(val);
        };
      });
      if (!pwd) return;
      const h = await hashString(pwd);
      if (!validHashes.includes(h)) { alert('å¯†ç¢¼éŒ¯èª¤ï¼Œç„¡æ³•åˆªé™¤ã€‚'); return; }
    }
    if (!confirm(`ç¢ºå®šè¦åˆªé™¤ç›®å‰å ´åœ°çš„æ‰€æœ‰ ${total} å ´è³‡æ–™ï¼Ÿæ­¤å‹•ä½œç„¡æ³•å¾©åŸã€‚`)) return;
    matchData = [];
    saveMatchData();
    renderTable();
  } catch(e){
    console.warn('deleteAllMatches error:', e);
    alert('åˆªé™¤æ™‚é‡åˆ°éŒ¯èª¤ï¼Œè«‹å†è©¦ä¸€æ¬¡ã€‚');
  }
}
window.addEventListener('DOMContentLoaded', () => {
  try {
    const cfg = getTtsConfig();
    const g = document.getElementById('ttsExtraTextGlobal');
    if (g) {
      g.value = cfg.extraText || '';
      g.addEventListener('input', () => {
        const c = getTtsConfig();
        c.extraText = (g.value || '').trim();
        setTtsConfig(c);
      });
    }
  } catch(e) { console.warn('init global extra text failed', e); }

      initDate();
      initLocations();
      initCourtTabs();
      switchCourt(1);
    });
    // === å°ˆæ³¨æª¢è¦–ï¼ˆæ”¾å¤§é¡ï¼‰ ===
    let focusModalInstance = null;

    function focusMatch(idx) {
      // æº–å‚™å…§å®¹
      const m = matchData[idx] || {};
      const players = getPlayers();

      const teamA = `
        <div class="col-md-6">
          <div class="card shadow-sm mb-3">
            <div class="card-body">
              <div class="focus-team-label text-primary mb-2">éšŠä¼ A</div>
              <div class="row g-3">
                <div class="col-12 col-lg-6">
                  <label class="focus-label">A1</label>
                  <select id="focus_A1" class="form-select focus-select teamA" onchange="updateField(${idx}, 'A1', this.value); refreshFocus(${idx});">
                    ${createPlayerOptionsFiltered(idx, 'A1', m.A1)}
                  </select>
                </div>
                <div class="col-12 col-lg-6">
                  <label class="focus-label">A2</label>
                  <select id="focus_A2" class="form-select focus-select teamA" onchange="updateField(${idx}, 'A2', this.value); refreshFocus(${idx});">
                    ${createPlayerOptionsFiltered(idx, 'A2', m.A2)}
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>`;

      const teamB = `
        <div class="col-md-6">
          <div class="card shadow-sm mb-3">
            <div class="card-body">
              <div class="focus-team-label text-danger mb-2">éšŠä¼ B</div>
              <div class="row g-3">
                <div class="col-12 col-lg-6">
                  <label class="focus-label">B1</label>
                  <select id="focus_B1" class="form-select focus-select teamB" onchange="updateField(${idx}, 'B1', this.value); refreshFocus(${idx});">
                    ${createPlayerOptionsFiltered(idx, 'B1', m.B1)}
                  </select>
                </div>
                <div class="col-12 col-lg-6">
                  <label class="focus-label">B2</label>
                  <select id="focus_B2" class="form-select focus-select teamB" onchange="updateField(${idx}, 'B2', this.value); refreshFocus(${idx});">
                    ${createPlayerOptionsFiltered(idx, 'B2', m.B2)}
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>`;

      const modeAndScore = `
        <div class="col-12">
          <div class="card shadow-sm">
            <div class="card-body">
              <div class="row g-3 align-items-center">
                <div class="col-md-3">
                  <label class="focus-label">S / D</label>
                  <select id="focus_SD" class="form-select focus-select" onchange="updateSD(${idx}, this.value); refreshFocus(${idx});">
                    <option value="S" ${m.SD==='S'?'selected':''}>S</option>
                    <option value="D" ${m.SD==='D'?'selected':''}>D</option>
                  </select>
                </div>
                <div class="col-md-4 text-center">
                  <div class="focus-label mb-1">A Score</div>
                  <input id="focus_AScore" type="number" class="form-control focus-score d-inline-block" value="${m.AScore||''}"
                    oninput="updateField(${idx}, 'AScore', this.value)">
                </div>
                <div class="col-md-2 text-center">
                  <button class="btn btn-primary btn-lg" onclick="confirmAndLock(${idx})">ç¢ºå®š</button>
                </div>
                <div class="col-md-3 text-center">
                  <div class="focus-label mb-1">B Score</div>
                  <input id="focus_BScore" type="number" class="form-control focus-score d-inline-block" value="${m.BScore||''}"
                    oninput="updateField(${idx}, 'BScore', this.value)">
                </div>
              </div>
            </div>
          </div>
        </div>`;

      const lockedBtn = m.locked
        ? `<button class="btn btn-success btn-lg" onclick="toggleLock(${idx}); setTimeout(()=>refreshFocus(${idx}), 0)">ğŸ”’ å·²é–å®š</button>`
        : `<button class="btn btn-outline-success btn-lg" onclick="toggleLock(${idx}); setTimeout(()=>refreshFocus(${idx}), 0)">ğŸ”“ æœªé–å®š</button>`;

      const header = `
        <div class="d-flex justify-content-between align-items-center mb-3">
          <div class="focus-title">ç¬¬ ${idx+1} å ´æ¯”è³½</div>
          <div class="d-flex gap-2">
            ${lockedBtn}
            <button class="btn btn-danger" onclick="confirmDelete(${idx}); const modalEl=document.getElementById('focusModal'); const modal=bootstrap.Modal.getInstance(modalEl); if(modal) modal.hide();">ğŸ—‘ï¸ åˆªé™¤æ­¤å ´</button>
            <button class="btn btn-secondary" data-bs-dismiss="modal">è¿”å›</button>
          </div>
        </div>`;

      const html = header + `<div class="row">${teamA}${teamB}${modeAndScore}</div>`;

      const container = document.getElementById('focusContent');
      container.innerHTML = html;

// å°‡é™„åŠ è³‡è¨Šçš„æ§åˆ¶é …èˆ‡ TTS è¨­å®šåŒæ­¥ï¼ˆå³å‹¾å³ç”Ÿæ•ˆã€å³è¼¸å…¥å³ä¿å­˜ï¼‰
try {
  const cfg0 = getTtsConfig();
  const cb = document.getElementById('ttsExtraEnabledFocus');
  const tx = document.getElementById('ttsExtraTextFocus');
  if (cb) {
    cb.checked = !!cfg0.extraEnabled;
    cb.addEventListener('change', () => {
      const c = getTtsConfig();
      c.extraEnabled = !!cb.checked;
      setTtsConfig(c);
    });
  }
  if (tx) {
    tx.value = cfg0.extraText || '';
    tx.addEventListener('input', () => {
      const c = getTtsConfig();
      c.extraText = (tx.value || '').trim();
      setTtsConfig(c);
    });
  }
} catch(e) { console.warn('Sync extra rules failed:', e); }

      // æ ¹æ“š S/D è¦å‰‡èª¿æ•´ A2 / B2
      renderFocusedSDRules(idx, m.SD);

      // é–‹å•Ÿ Modal
      const modalEl = document.getElementById('focusModal');
      focusModalInstance = focusModalInstance || new bootstrap.Modal(modalEl);
      focusModalInstance.show();
    }

    function refreshFocus(idx) {
      // é‡æ–°æ¸²æŸ“æ•´é«”åˆ—è¡¨ï¼Œç¢ºä¿åŒæ­¥
      renderTable();
      // é‡æ–°é–‹å•Ÿç•¶å‰å°ˆæ³¨å…§å®¹ï¼ˆè‹¥ modal æ­£åœ¨é–‹å•Ÿä¸­å‰‡æ›´æ–°å…§å®¹å³å¯ï¼‰
      const modalEl = document.getElementById('focusModal');
      if (modalEl.classList.contains('show')) {
        focusMatch(idx);
      }
    }

    function confirmAndLock(idx) {
      const aEl = document.getElementById('focus_AScore');
      const bEl = document.getElementById('focus_BScore');
      const aVal = aEl ? aEl.value : '';
      const bVal = bEl ? bEl.value : '';
      // å¯«å›æ¯”åˆ†ï¼ˆä¿éšªå†å¯«ä¸€æ¬¡ï¼‰
      if (aEl) updateField(idx, 'AScore', aVal);
      if (bEl) updateField(idx, 'BScore', bVal);
      saveMatchData && saveMatchData();
      if (confirm('æ˜¯å¦ç¢ºèªæ­¤æ¯”åˆ†ï¼Ÿç¢ºèªå¾Œå°‡ç›´æ¥é–å®šè©²å ´æ¯”è³½')) {
        matchData[idx].locked = true; // set true safely
        saveMatchData();
        renderTable();
        // é—œé–‰ Modal
        const modalEl = document.getElementById('focusModal');
        const modal = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
        modal.hide();
        // è¿”å›ä¸»ç•«é¢å¾Œè‡ªå‹•æª¢æŸ¥ä¸‹ä¸€å ´æ¬¡æˆ–çµæŸæ’­å ±
        setTimeout(() => {
          try {
            const nextIdx = findNextUnfinishedIndex(idx);
            if (nextIdx >= 0) {
              announceMatch(nextIdx);
            } else {
              const total = (matchData || []).filter(mm => mm && mm.locked === true).length;
              speak(`æœ¬æ—¥è³½ç¨‹å·²çµæŸï¼Œå…±é€²è¡Œäº† ${total} å ´æ¯”è³½ã€‚`);
            }
          } catch(e){ console.warn('post-confirm announce failed', e); }
        }, 400);
        }
    }

    function renderFocusedSDRules(idx, sd) {
      const a2 = document.getElementById('focus_A2');
      const b2 = document.getElementById('focus_B2');
      if (!a2 || !b2) return;
      if (sd === 'S') {
        a2.disabled = true; a2.value = '';
        b2.disabled = true; b2.value = '';
      } else {
        a2.disabled = false; b2.disabled = false;
      }
    }

    
    // å°‹æ‰¾ä¸‹ä¸€å ´å°šæœªå®Œæˆï¼ˆæœªé–å®šï¼‰ä¸”å…·å‚™åŸºæœ¬é¸æ‰‹è³‡è¨Šçš„å ´æ¬¡
    function findNextUnfinishedIndex(startIdx){
      for(let i = startIdx + 1; i < matchData.length; i++){
        const m = matchData[i];
        if(!m) continue;
        if(m.locked === true) continue; // å·²å®Œæˆ
        // è‡³å°‘ A1 èˆ‡ B1 éœ€å­˜åœ¨ï¼Œå–®æ‰“/é›™æ‰“çš†é©ç”¨ï¼ˆé›™æ‰“è‹¥ A2/B2 æœªå¡«ï¼Œä¹Ÿå…ˆå…è¨±æ’­å ±ï¼‰
        if((m.A1 && String(m.A1).trim()) && (m.B1 && String(m.B1).trim())){
          return i;
        }
      }
      return -1;
    }
    // === èªéŸ³æ’­å ±ï¼šé»é¸å ´æ¬¡ç·¨è™Ÿè®€å‡ºä¸Šå ´é¸æ‰‹ ===
    let zhTwVoice = null;
    function loadVoices() {
      const voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
      // å˜—è©¦æ‰¾ç¹ä¸­èªéŸ³ï¼ˆzh-TW æˆ– zh_HANT ç­‰ï¼‰
      zhTwVoice = null;
      for (const v of voices) {
        const lang = (v.lang || '').toLowerCase();
        if (lang.includes('zh') && (lang.includes('tw') || lang.includes('hant'))) {
          zhTwVoice = v;
          break;
        }
      }
      return voices;
    }
    if (window.speechSynthesis) {
      loadVoices();
      window.speechSynthesis.onvoiceschanged = () => loadVoices();
    }

    function speak(text) {
      if (!window.speechSynthesis) {
        alert(text); // ç€è¦½å™¨ä¸æ”¯æŒæ™‚è‡³å°‘é¡¯ç¤ºæ–‡å­—
        return;
      }
      window.speechSynthesis.cancel(); // åœæ‰å‰ä¸€æ®µ
      const utter = new SpeechSynthesisUtterance(text);
      if (zhTwVoice) utter.voice = zhTwVoice;
      utter.lang = zhTwVoice ? zhTwVoice.lang : 'zh-TW';
      utter.rate = 1; // èªé€Ÿ
      utter.pitch = 1;
      window.speechSynthesis.speak(utter);
    }

    function buildAnnouncement(m, idx) {
      const n = (idx + 1);
      const isSingles = (m.SD === 'S');
      const A1 = m.A1 || 'A1';
      const A2 = m.A2 || '';
      const B1 = m.B1 || 'B1';
      const B2 = m.B2 || '';
      if (isSingles) {
        return `ç¬¬ ${n} å ´æ¬¡ï¼ŒAéšŠï¼š${A1}ï¼Œå°ä¸Šï¼ŒBéšŠï¼š${B1}ã€‚`;
      } else {
        const aPair = (A1 && A2) ? `${A1} èˆ‡ ${A2}` : `${A1}${A2?(' èˆ‡ ' + A2):''}`;
        const bPair = (B1 && B2) ? `${B1} èˆ‡ ${B2}` : `${B1}${B2?(' èˆ‡ ' + B2):''}`;
        return `ç¬¬ ${n} å ´æ¬¡ï¼ŒAéšŠï¼š${aPair}ï¼ŒBéšŠï¼š${bPair}ã€‚`;
      }
    }

    function announceMatch(idx) {
      const m = matchData[idx];
      if (!m) return;
      // ä½¿ç”¨ composeAnnouncementï¼šæœƒä¾è¦å‰‡è‡ªå‹•æ¥ä¸Šã€Œé™„åŠ è³‡è¨Šã€èˆ‡ã€Œçµå°¾èªã€ï¼Œé †åºç‚ºï¼šé¸æ‰‹ä»‹ç´¹ â†’ é™„åŠ è³‡è¨Šï¼ˆæœªé–å®šä¸”å‹¾é¸ï¼‰ â†’ çµå°¾èªã€‚
      const text = composeAnnouncement(m, idx);
      speak(text);
    }

    // === TTS è¨­å®šï¼ˆå¯é¸èªéŸ³ã€èªé€Ÿã€éŸ³é«˜ï¼Œä¸¦ä¿å­˜æ–¼ localStorageï¼‰ ===
    const TTS_CFG_KEY = 'tts_config_v1';
    function getTtsConfig() {
      try { return JSON.parse(localStorage.getItem(TTS_CFG_KEY)) || {}; } catch { return {}; }
    }
    function setTtsConfig(cfg) {
      localStorage.setItem(TTS_CFG_KEY, JSON.stringify(cfg || {}));
    }

    function populateVoiceSelect() {
      const sel = document.getElementById('ttsVoiceSelect');
      if (!sel || !window.speechSynthesis) return;
      const voices = window.speechSynthesis.getVoices();
      sel.innerHTML = '';
      const cfg = getTtsConfig();

      // æ’åºï¼šä¸­æ–‡åœ¨å‰ï¼ˆzh-* æˆ– hans/hantï¼‰ï¼Œå†å…¶ä»–ï¼›åŒèªç³»æŒ‰åç¨±
      const sorted = [...voices].sort((a,b)=>{
        const ax = ((a.lang||'') + a.name).toLowerCase();
        const bx = ((b.lang||'') + b.name).toLowerCase();
        const aZh = ax.includes('zh') || ax.includes('hant') || ax.includes('hans');
        const bZh = bx.includes('zh') || bx.includes('hant') || bx.includes('hans');
        if (aZh !== bZh) return aZh ? -1 : 1;
        return ax.localeCompare(bx);
      });

      sorted.forEach(v=>{
        const opt = document.createElement('option');
        opt.value = v.voiceURI || v.name;
        opt.textContent = `${v.name} â€” ${v.lang}`;
        sel.appendChild(opt);
      });

      // é è¨­é¸æ“‡ï¼šå…ˆç”¨å·²ä¿å­˜ï¼Œå…¶æ¬¡ zh-TW/hantï¼Œå…¶æ¬¡ç¬¬ä¸€å€‹
      let chosen = cfg.voiceURI;
      if (!chosen) {
        const firstZh = sorted.find(v=>{
          const L=(v.lang||'').toLowerCase();
          return L.includes('zh') && (L.includes('tw') || L.includes('hant'));
        }) || sorted.find(v=>(v.lang||'').toLowerCase().includes('zh'));
        chosen = firstZh ? (firstZh.voiceURI || firstZh.name) : (sorted[0] ? (sorted[0].voiceURI || sorted[0].name) : '');
      }
      if (chosen) sel.value = chosen;
      document.getElementById('ttsRate').value = cfg.rate ?? 0.95;
      document.getElementById('ttsPitch').value = cfg.pitch ?? 1.0;
      document.getElementById('ttsRateVal').textContent = document.getElementById('ttsRate').value;
      document.getElementById('ttsPitchVal').textContent = document.getElementById('ttsPitch').value;
      if (document.getElementById('ttsEndingLocked')) document.getElementById('ttsEndingLocked').value = cfg.endingLocked ?? '';
      if (document.getElementById('ttsEndingUnlocked')) document.getElementById('ttsEndingUnlocked').value = cfg.endingUnlocked ?? '';
      if (document.getElementById('ttsExtraEnabled')) /* removed: extraEnabled checkbox */
      if (document.getElementById('ttsExtraText')) document.getElementById('ttsExtraText').value = cfg.extraText ?? '';
    }

    function getVoiceByURI(uri) {
      const voices = window.speechSynthesis.getVoices();
      return voices.find(v => (v.voiceURI === uri) || (v.name === uri));
    }

    // è¦†å¯« speakï¼Œä½¿å…¶æ¡ç”¨ä½¿ç”¨è€…è¨­å®š
    function speak(text) {
      if (!window.speechSynthesis) {
        alert(text);
        return;
      }
      const cfg = getTtsConfig();
      const pick = getVoiceByURI(cfg.voiceURI) || zhTwVoice;
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      if (pick) utter.voice = pick;
      utter.lang = pick?.lang || 'zh-TW';
      utter.rate = Number(cfg.rate ?? 0.95);
      utter.pitch = Number(cfg.pitch ?? 1.0);
      window.speechSynthesis.speak(utter);
    }

    // åˆå§‹åŒ– modal æ§åˆ¶
    document.addEventListener('DOMContentLoaded', ()=>{
      if (window.speechSynthesis) {
        populateVoiceSelect();
        window.speechSynthesis.onvoiceschanged = populateVoiceSelect;
      }
      const rate = document.getElementById('ttsRate');
      const pitch = document.getElementById('ttsPitch');
      if (rate) rate.addEventListener('input', ()=>{ document.getElementById('ttsRateVal').textContent = rate.value; });
      if (pitch) pitch.addEventListener('input', ()=>{ document.getElementById('ttsPitchVal').textContent = pitch.value; });

      const preview = document.getElementById('ttsPreviewBtn');
      if (preview) preview.addEventListener('click', ()=>{
        const sel = document.getElementById('ttsVoiceSelect');
        const cfg = getTtsConfig();
        cfg.voiceURI = sel.value;
        cfg.rate = Number(document.getElementById('ttsRate').value);
        cfg.pitch = Number(document.getElementById('ttsPitch').value);
        setTtsConfig(cfg);
        // ç”¨ç›®å‰ä¸‹ä¸€å€‹æœªé–å®šå ´æ¬¡åšè©¦è½ï¼Œæ‰¾ä¸åˆ°å‰‡ç”¨é è¨­å¥
        const idx = (matchData || []).findIndex(m=>!m.locked);
        let text = 'é€™æ˜¯èªéŸ³æ¸¬è©¦ã€‚';
        if (idx>=0) {
          text = composeAnnouncement(matchData[idx], idx);
        } else {
          // è‹¥å…¨éƒ¨é–å®šï¼Œå–æœ€å¾Œä¸€å ´è©¦è½
          const j = (matchData || []).length - 1;
          if (j>=0) text = composeAnnouncement(matchData[j], j);
        }
        speak(text);
      });

      const save = document.getElementById('ttsSaveBtn');
      if (save) save.addEventListener('click', ()=>{
        const cfg = getTtsConfig();
        cfg.voiceURI = document.getElementById('ttsVoiceSelect').value;
        cfg.rate = Number(document.getElementById('ttsRate').value);
        cfg.pitch = Number(document.getElementById('ttsPitch').value);
        cfg.endingLocked = (document.getElementById('ttsEndingLocked').value || '').trim();
        cfg.endingUnlocked = (document.getElementById('ttsEndingUnlocked').value || '').trim();
        setTtsConfig(cfg);
        const modalEl = document.getElementById('ttsSettingsModal');
        const modal = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
        modal.hide();
      });
    });

    // === æ¯”è³½åœ°é»æ¸…å–®ï¼ˆlocalStorageï¼‰ ===
    const LOC_KEY = 'dupr_locations_v1';
    const LOC_SEL_KEY = 'dupr_selected_location_v1';

    function getLocations() {
      try { return JSON.parse(localStorage.getItem(LOC_KEY)) || []; } catch { return []; }
    }
    function setLocations(list) {
      localStorage.setItem(LOC_KEY, JSON.stringify(list || []));
      try { scheduleSaveLocations && scheduleSaveLocations(); } catch(e) { /* ignore */ }
    }

    function renderLocationOptions() {
      const sel = document.getElementById('locationInput');
      if (!sel) return;
      const list = getLocations();
      sel.innerHTML = '';
      list.forEach(loc => {
        const opt = document.createElement('option');
        opt.value = loc;
        opt.textContent = loc;
        sel.appendChild(opt);
      });
      const chosen = localStorage.getItem(LOC_SEL_KEY);
      if (chosen && list.includes(chosen)) {
        sel.value = chosen;
      } else if (list.length) {
        sel.value = list[0];
        localStorage.setItem(LOC_SEL_KEY, list[0]);
      }
      sel.addEventListener('change', () => {
        localStorage.setItem(LOC_SEL_KEY, sel.value);
      }, { once: true });
      sel.addEventListener('change', () => { try { scheduleSaveLocations && scheduleSaveLocations(); } catch(e){} });
    }

    function initLocations() {
      const sel = document.getElementById('locationInput');
      if (!sel) return;
      let list = getLocations();
      const def = sel.getAttribute('data-default');
      // åˆæ¬¡ä½¿ç”¨è‡ªå‹•å¸¶å…¥é è¨­åœ°é»
      if (!list.length && def) list = [def];
      // å»é‡
      list = Array.from(new Set(list.filter(Boolean)));
      setLocations(list);
      renderLocationOptions();
    }

    function addLocation() {
      const name = (prompt('è«‹è¼¸å…¥æ–°çš„æ¯”è³½åœ°é»ï¼š') || '').trim();
      if (!name) return;
      let list = getLocations();
      if (!list.includes(name)) {
        list.push(name);
        setLocations(list);
      }
      localStorage.setItem(LOC_SEL_KEY, name);
      renderLocationOptions();
    }

    // === åœ°é»ç®¡ç†ï¼ˆé‡å‘½åã€åˆªé™¤ã€æ’åºï¼‰ ===
    function renderLocationsManager() {
      const list = getLocations();
      const ul = document.getElementById('locMgrList');
      if (!ul) return;
      ul.innerHTML = '';
      list.forEach((name, i) => {
        const li = document.createElement('li');
        li.className = 'list-group-item d-flex justify-content-between align-items-center';
        li.innerHTML = `
          <span class="text-truncate" style="max-width: 70%">${name}</span>
          <div class="btn-group btn-group-sm">
            <button class="btn btn-outline-secondary" title="ä¸Šç§»" onclick="moveLocation(${i}, -1)">â–²</button>
            <button class="btn btn-outline-secondary" title="ä¸‹ç§»" onclick="moveLocation(${i}, 1)">â–¼</button>
            <button class="btn btn-outline-primary" title="é‡å‘½å" onclick="renameLocation(${i})">âœ</button>
            <button class="btn btn-outline-danger" title="åˆªé™¤" onclick="deleteLocation(${i})">ğŸ—‘</button>
          </div>`;
        ul.appendChild(li);
      });
    }

    function renameLocation(i) {
      let list = getLocations();
      const old = list[i];
      const name = (prompt('è«‹è¼¸å…¥æ–°çš„åœ°é»åç¨±ï¼š', old) || '').trim();
      if (!name) return;
      if (list.includes(name) && name !== old) {
        alert('æ­¤åç¨±å·²å­˜åœ¨ï¼Œè«‹æ”¹ç”¨å…¶ä»–åç¨±ã€‚');
        return;
      }
      list[i] = name;
      setLocations(list);
      // è‹¥æ”¹åçš„æ˜¯ç›®å‰é¸æ“‡çš„åœ°é»ï¼ŒåŒæ­¥æ›´æ–°é¸æ“‡
      const sel = localStorage.getItem(LOC_SEL_KEY);
      if (sel === old) localStorage.setItem(LOC_SEL_KEY, name);
      renderLocationOptions();
      renderLocationsManager();
    }

    function deleteLocation(i) {
      let list = getLocations();
      const target = list[i];
      if (!confirm(`ç¢ºå®šåˆªé™¤ã€Œ${target}ã€ï¼Ÿ`)) return;
      list.splice(i, 1);
      setLocations(list);
      // å¦‚åˆªé™¤ç›®å‰é¸æ“‡çš„åœ°é»ï¼Œåˆ‡å›ç¬¬ä¸€å€‹æˆ–æ¸…ç©º
      const sel = localStorage.getItem(LOC_SEL_KEY);
      if (sel === target) {
        if (list.length) localStorage.setItem(LOC_SEL_KEY, list[0]);
        else localStorage.removeItem(LOC_SEL_KEY);
      }
      renderLocationOptions();
      renderLocationsManager();
    }

    function moveLocation(i, dir) {
      let list = getLocations();
      const j = i + dir;
      if (j < 0 || j >= list.length) return;
      const tmp = list[i];
      list[i] = list[j];
      list[j] = tmp;
      setLocations(list);
      renderLocationOptions();
      renderLocationsManager();
    }

    // é¡¯ç¤ºç®¡ç†è¦–çª—æ™‚åˆ·æ–°åˆ—è¡¨
    document.addEventListener('DOMContentLoaded', () => {
      const modalEl = document.getElementById('locationsManagerModal');
      if (modalEl) {
        modalEl.addEventListener('shown.bs.modal', renderLocationsManager);
      }
    });

    // === æ¯”è³½æ—¥æœŸï¼šé è¨­ä»Šæ—¥ï¼Œä¸”è¨˜ä½æœ€å¾Œé¸æ“‡ ===
    const DATE_KEY = 'dupr_selected_date_v1';
    function initDate() {
      const el = document.getElementById('dateInput');
      if (!el) return;
      let saved = localStorage.getItem(DATE_KEY);
      if (saved) {
        el.value = saved;
      } else {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth()+1).padStart(2,'0');
        const dd = String(now.getDate()).padStart(2,'0');
        el.value = `${yyyy}-${mm}-${dd}`;
      }
      el.addEventListener('change', ()=>{
        localStorage.setItem(DATE_KEY, el.value || '');
      }, { once: true });
    }

    function replaceVars(tpl, vars) {
      return (tpl || '').replace(/\{(\w+)\}/g, (_, k) => (k in vars ? vars[k] : ''));
    }

    function buildEnding(m, idx) {
      const cfg = getTtsConfig();
      const n = idx + 1;
      const court = (localStorage.getItem('courtName_' + (currentCourt||1)) || (currentCourt + 'è™Ÿå ´åœ°'));
      if (m.locked) {
        const a = parseInt(m.AScore, 10);
        const b = parseInt(m.BScore, 10);
        let winner = '';
        if (!isNaN(a) && !isNaN(b) && a !== b) {
          winner = (a > b) ? 'AéšŠ' : 'BéšŠ';
        } else {
          // ç„¡æ³•åˆ¤å®šæˆ–å¹³æ‰‹
          winner = 'é›™æ–¹ï¼ˆæ¯”åˆ†æœªåˆ¤å®šï¼‰';
        }
        const tpl = cfg.endingLocked || 'æœ¬å ´æ¯”è³½ç”± {winner} ç²å‹ã€‚';
        return replaceVars(tpl, { winner, court, match: `ç¬¬ ${n} å ´æ¬¡` });
      } else {
        const tpl = cfg.endingUnlocked || 'è«‹é›™æ–¹éšŠä¼é¸æ‰‹è‡³ {court} é€²è¡Œæ¯”è³½ã€‚';
        return replaceVars(tpl, { court, match: `ç¬¬ ${n} å ´æ¬¡` });
      }
    }

    function composeAnnouncement(m, idx) {
      const base = buildAnnouncement(m, idx);
      const cfg = getTtsConfig();
      let extra = '';
      if (cfg.extraText && cfg.extraText.trim()) {
        extra = ' ' + cfg.extraText.trim();
      }
      const ending = buildEnding(m, idx);
      return base + extra + (ending ? (' ' + ending) : '');
    }

    // è¦†å¯« announceMatch ä½¿ç”¨ composeAnnouncementï¼ˆå«çµå°¾ç”¨èªï¼‰
    function announceMatch(idx) {
      const m = matchData[idx];
      if (!m) return;
      const text = composeAnnouncement(m, idx);
      speak(text);
    }

  </script>

  <!-- Focus Modal -->
  <div class="modal fade" id="focusModal" tabindex="-1" aria-labelledby="focusModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="focusModalLabel">å°ˆæ³¨æª¢è¦–</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div id="focusContent" class="container py-3"></div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">è¿”å›</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <!-- èªéŸ³è¨­å®š Modal -->
  <div class="modal fade" id="ttsSettingsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">èªéŸ³è¨­å®š</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <label class="form-label">èªéŸ³ï¼ˆVoiceï¼‰</label>
            <select id="ttsVoiceSelect" class="form-select"></select>
            <div class="form-text">å»ºè­°é¸æ“‡ zh-TW/ç¹é«”ä¸­æ–‡ æˆ–ä½ è¦ºå¾—è‡ªç„¶çš„ä¸­æ–‡èªéŸ³ã€‚</div>
          </div>
          <div class="mb-3">
            <label class="form-label">èªé€Ÿï¼ˆRateï¼‰ <span id="ttsRateVal"></span></label>
            <input id="ttsRate" type="range" min="0.7" max="1.2" step="0.05" value="95%" class="form-range">
          </div>
          <div class="mb-3">
            <label class="form-label">éŸ³é«˜ï¼ˆPitchï¼‰ <span id="ttsPitchVal"></span></label>
            <input id="ttsPitch" type="range" min="0.8" max="1.2" step="0.05" value="1.00" class="form-range">
          </div>
          <hr/>
          <div class="mb-2">
            <label class="form-label">æ’­å ±çµå°¾ç”¨èªï¼ˆé–å®šå ´æ¬¡ï¼‰</label>
            <input id="ttsEndingLocked" type="text" class="form-control" placeholder="æœ¬å ´æ¯”è³½ç”± {winner} ç²å‹ã€‚">
            <div class="form-text">å¯ç”¨è®Šæ•¸ï¼š{winner}ï¼ˆAéšŠ/BéšŠï¼‰ï¼Œ{court}ï¼ˆç›®å‰å ´åœ°åç¨±ï¼‰ï¼Œ{match}ï¼ˆç¬¬ N å ´æ¬¡ï¼‰ã€‚</div>
          </div>
          <div class="mb-3">
            <label class="form-label">æ’­å ±çµå°¾ç”¨èªï¼ˆæœªé–å®šå ´æ¬¡ï¼‰</label>
            <input id="ttsEndingUnlocked" type="text" class="form-control" placeholder="è«‹é›™æ–¹éšŠä¼é¸æ‰‹è‡³ {court} é€²è¡Œæ¯”è³½ã€‚">
            <div class="form-text">ä¾‹å¦‚ï¼šè«‹é›™æ–¹éšŠä¼é¸æ‰‹è‡³ ç©ç©—åœ‹å°3è™Ÿçƒå ´ é€²è¡Œæ¯”è³½ã€‚ä¹Ÿå¯ç”¨ {court} è‡ªå‹•å¸¶å…¥ç›®å‰å ´åœ°åç¨±ã€‚</div>
          </div>
          <div class="d-flex gap-2">
            <button class="btn btn-secondary" id="ttsPreviewBtn">è©¦è½</button>
            <button class="btn btn-primary" id="ttsSaveBtn">ä¿å­˜</button>
          </div>
        </div>
      </div>
    </div>
  </div>


  <!-- åœ°é»ç®¡ç† Modal -->
  <div class="modal fade" id="locationsManagerModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">åœ°é»ç®¡ç†</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <div class="form-text">å¯é‡å‘½åã€åˆªé™¤ã€æ’åºã€‚æ’åºæœƒç›´æ¥å½±éŸ¿ä¸‹æ‹‰æ¸…å–®çš„é¡¯ç¤ºé †åºã€‚</div>
            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="addLocation(); renderLocationsManager();">ï¼‹ æ–°å¢åœ°é»</button>
          </div>
          <ul class="list-group" id="locMgrList"></ul>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">é—œé–‰</button>
        </div>
      </div>
    </div>
  </div>


<script>
(function(){
  function getExtraTemplates(){
    try { return JSON.parse(localStorage.getItem('ttsExtraTemplates') || '[]'); }
    catch(e){ return []; }
  }
  function setExtraTemplates(arr){
    const clean = Array.from(new Set((arr || []).map(s => (s || '').trim()).filter(Boolean)));
    localStorage.setItem('ttsExtraTemplates', JSON.stringify(clean));
  }
  function populateExtraTemplateSelect(){
    const sel = document.getElementById('ttsExtraTemplateSelect');
    if(!sel) return;
    const list = getExtraTemplates();
    sel.innerHTML = '';
    if(list.length === 0){
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'ï¼ˆå°šç„¡ç¯„æœ¬ï¼‰';
      sel.appendChild(opt);
      sel.disabled = true;
    } else {
      sel.disabled = false;
      list.forEach((t, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = t;
        sel.appendChild(opt);
      });
    }
  }
  window.addEventListener('DOMContentLoaded', () => {
    const g = document.getElementById('ttsExtraTextGlobal');
    const sel = document.getElementById('ttsExtraTemplateSelect');
    const btnApply  = document.getElementById('extraTplApplyBtn');
    const btnSave   = document.getElementById('extraTplSaveBtn');
    const btnUpdate = document.getElementById('extraTplUpdateBtn');
    const btnDelete = document.getElementById('extraTplDeleteBtn');

    populateExtraTemplateSelect();

    btnSave && btnSave.addEventListener('click', () => {
      const v = (g?.value || '').trim();
      if(!v) return;
      const list = getExtraTemplates();
      if(!list.includes(v)) list.push(v);
      setExtraTemplates(list);
      populateExtraTemplateSelect();
      const idx = getExtraTemplates().indexOf(v);
      if(sel && idx >= 0) sel.value = String(idx);
    });

    btnApply && btnApply.addEventListener('click', () => {
      const list = getExtraTemplates();
      const idx = parseInt(sel?.value ?? '-1', 10);
      if(!isNaN(idx) && list[idx] != null && g){
        g.value = list[idx];
        // è§¸ç™¼åŸæœ¬çš„ input ç›£è½ï¼Œè®“è¨­å®šå³æ™‚ä¿å­˜
        g.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });

    btnUpdate && btnUpdate.addEventListener('click', () => {
      const list = getExtraTemplates();
      const idx = parseInt(sel?.value ?? '-1', 10);
      const v = (g?.value || '').trim();
      if(!isNaN(idx) && idx >= 0 && list[idx] != null && v){
        list[idx] = v;
        setExtraTemplates(list);
        populateExtraTemplateSelect();
        if(sel) sel.value = String(idx);
      }
    });

    btnDelete && btnDelete.addEventListener('click', () => {
      const list = getExtraTemplates();
      const idx = parseInt(sel?.value ?? '-1', 10);
      if(!isNaN(idx) && idx >= 0 && list[idx] != null){
        list.splice(idx, 1);
        setExtraTemplates(list);
        populateExtraTemplateSelect();
      }
    });
  });
})();
</script>


  <!-- Firebase (optional, used for cross-device sync of locations) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.1/firebase-firestore-compat.js"></script>
  <script>
    (function(){
      let fbApp = null, auth = null, db = null, currentUser = null;
      let locDocUnsub = null;
      let suppressCloudSave = false;

      function getFirebaseConfig(){
        try {
          const raw = localStorage.getItem('dupr_firebase_config_json');
          if (raw) return JSON.parse(raw);
        } catch(e){}
        return null;
      }

      window.promptFirebaseConfig = function(){
        const oldV = localStorage.getItem('dupr_firebase_config_json') || '{\n  "apiKey": "",\n  "authDomain": "",\n  "projectId": ""\n}';
        const v = prompt('è«‹è²¼ä¸Š Firebase è¨­å®š JSONï¼ˆåƒ…éœ€ apiKey / authDomain / projectIdï¼‰\n\nè²¼ä¸Šå¾Œæœƒä¿å­˜åˆ°æ­¤è£ç½®çš„ç€è¦½å™¨å„²å­˜ï¼Œä¹‹å¾Œå¯éš¨æ™‚ä¿®æ”¹ã€‚', oldV);
        if (!v) return;
        try {
          const cfg = JSON.parse(v);
          if (!cfg.apiKey || !cfg.projectId) throw new Error('ç¼ºå°‘å¿…è¦æ¬„ä½');
          localStorage.setItem('dupr_firebase_config_json', JSON.stringify(cfg));
          alert('è¨­å®šå·²ä¿å­˜ï¼Œç¾åœ¨é‡æ–°æ•´ç†é é¢ä»¥ç”Ÿæ•ˆã€‚');
          location.reload();
        } catch(e){
          alert('JSON æ ¼å¼éŒ¯èª¤æˆ–ç¼ºå°‘æ¬„ä½ï¼š' + e.message);
        }
      };

      function initFirebase(){
        const cfg = getFirebaseConfig();
        if (!cfg || !window.firebase || !firebase.initializeApp) { updateAuthUI(); return; }
        try {
          fbApp = firebase.apps && firebase.apps.length ? firebase.app() : firebase.initializeApp(cfg);
          auth = firebase.auth();
          db = firebase.firestore();
          auth.onAuthStateChanged(async (u) => {
            currentUser = u || null;
            updateAuthUI();
            if (currentUser) {
              attachLocationsListener();
              await syncLocationsFromCloud();
            } else {
              detachLocationsListener();
            }
          });
        } catch(e){
          console.warn('Firebase init failed:', e);
        }
      }

      function updateAuthUI(){
        const loginBtn = document.getElementById('loginBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const status = document.getElementById('authStatus');
        const hasCfg = !!getFirebaseConfig();
        if (loginBtn) loginBtn.disabled = !hasCfg;
        if (status) {
          if (!hasCfg) status.textContent = 'å°šæœªè¨­å®š Firebaseï¼šç›®å‰åƒ…ä¿å­˜åœ¨æ­¤è£ç½®';
          else if (!currentUser) status.textContent = 'æœªç™»å…¥ï¼šç›®å‰åƒ…ä¿å­˜åœ¨æ­¤è£ç½®ï¼ˆå¯ç™»å…¥ä»¥å•Ÿç”¨è·¨è£ç½®åŒæ­¥ï¼‰';
          else status.textContent = 'å·²ç™»å…¥ï¼š' + (currentUser.email || currentUser.uid) + 'ï¼ˆåœ°é»å°‡è‡ªå‹•èˆ‡é›²ç«¯åŒæ­¥ï¼‰';
        }
        if (loginBtn) loginBtn.classList.toggle('d-none', !!currentUser);
        if (logoutBtn) logoutBtn.classList.toggle('d-none', !currentUser);
      }

      window.signInWithGoogle = async function(){
        if (!auth) { alert('å°šæœªè¨­å®š Firebaseã€‚è«‹å…ˆé»ã€ŒFirebase è¨­å®šã€ã€‚'); return; }
        try {
          const provider = new firebase.auth.GoogleAuthProvider();
          await auth.signInWithPopup(provider);
        } catch(e){
          console.warn('signIn failed:', e);
          alert('ç™»å…¥å¤±æ•—ï¼š' + (e && e.message ? e.message : e));
        }
      };

      window.signOutFirebase = async function(){
        if (!auth) return;
        await auth.signOut();
      };

      function getCloudDocRef(){
        if (!db || !currentUser) return null;
        return db.collection('dupr_locations').doc(currentUser.uid);
      }

      function detachLocationsListener(){
        if (locDocUnsub) { locDocUnsub(); locDocUnsub = null; }
      }

      function attachLocationsListener(){
        detachLocationsListener();
        const ref = getCloudDocRef();
        if (!ref) return;
        locDocUnsub = ref.onSnapshot((snap)=>{
          const data = snap && snap.exists ? snap.data() : null;
          if (!data) return;
          const cloud = Array.from(new Set((data.locations || []).filter(Boolean)));
          const chosen = data.selected || '';
          suppressCloudSave = true;
          try {
            const localList = getLocations();
            const equals = JSON.stringify(localList) === JSON.stringify(cloud);
            const localSel = (localStorage.getItem('dupr_selected_location_v1') || '');
            if (!equals || localSel !== chosen) {
              setLocations(cloud);
              if (chosen) localStorage.setItem('dupr_selected_location_v1', chosen);
              renderLocationOptions && renderLocationOptions();
            }
          } finally {
            suppressCloudSave = false;
          }
        }, (err)=>console.warn('onSnapshot error:', err));
      }

      async function readCloudLocations(){
        const ref = getCloudDocRef(); if (!ref) return { locations: [], selected: '' };
        const snap = await ref.get();
        if (!snap.exists) return { locations: [], selected: '' };
        const data = snap.data() || {};
        return { locations: Array.from(new Set((data.locations || []).filter(Boolean))), selected: data.selected || '' };
      }

      async function writeCloudLocations(list, selected){
        const ref = getCloudDocRef(); if (!ref) return;
        await ref.set({
          locations: Array.from(new Set((list || []).filter(Boolean))),
          selected: selected || '',
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
      }

      window.syncLocationsNow = async function(){
        try {
          await syncLocationsFromCloud(true);
          alert('åŒæ­¥å®Œæˆ');
        } catch(e){
          alert('åŒæ­¥å¤±æ•—ï¼š' + (e && e.message ? e.message : e));
        }
      };

      async function syncLocationsFromCloud(forceWrite=false){
        if (!db || !currentUser) return;
        const cloud = await readCloudLocations();
        const localList = getLocations();
        const localSel = (localStorage.getItem('dupr_selected_location_v1') || '');
        const merged = Array.from(new Set([...(cloud.locations||[]), ...(localList||[])]));
        const chosen = localSel || cloud.selected || (merged[0] || '');

        const cloudChanged = JSON.stringify(merged) !== JSON.stringify(cloud.locations || []) || (chosen !== (cloud.selected || ''));
        const localChanged = JSON.stringify(merged) !== JSON.stringify(localList) || chosen !== localSel;

        if (localChanged) {
          suppressCloudSave = true;
          try {
            setLocations(merged);
            if (chosen) localStorage.setItem('dupr_selected_location_v1', chosen);
            renderLocationOptions && renderLocationOptions();
          } finally {
            suppressCloudSave = false;
          }
        }
        if (cloudChanged || forceWrite) {
          await writeCloudLocations(merged, chosen);
        }
      }

      let saveLocTimer = null;
      window.scheduleSaveLocations = function(){
        if (suppressCloudSave) return;
        if (!db || !currentUser) return;
        clearTimeout(saveLocTimer);
        saveLocTimer = setTimeout(async () => {
          try {
            const list = getLocations();
            const sel = (localStorage.getItem('dupr_selected_location_v1') || '');
            await writeCloudLocations(list, sel);
          } catch(e){ console.warn('save to cloud failed', e); }
        }, 500);
      };

      document.addEventListener('DOMContentLoaded', () => {
        try {
          initFirebase();
          const modalEl = document.getElementById('locationsManagerModal');
          if (modalEl) {
            modalEl.addEventListener('shown.bs.modal', () => {
              const hdr = modalEl.querySelector('.modal-header');
              if (hdr && !hdr.querySelector('#syncLocationsBtn')) {
                const btn = document.createElement('button');
                btn.id = 'syncLocationsBtn';
                btn.className = 'btn btn-sm btn-outline-primary';
                btn.textContent = 'â†º åŒæ­¥é›²ç«¯';
                btn.onclick = () => window.syncLocationsNow && window.syncLocationsNow();
                const right = hdr.querySelector('.btn-close');
                hdr.insertBefore(btn, right);
              }
            });
          }
        } catch(e){ console.warn('init sync ui failed', e); }
      });

    })();
  </script>


<script>
(function(){
  const server = localStorage.getItem('cloud_tts_server') || 'http://localhost:8787/api/tts';

  const pref = {
    useCloud: localStorage.getItem('use_cloud_tts') === '1',
    voice: localStorage.getItem('cloud_voice') || 'zh-TW-HsiaoChenNeural',
    rate:  localStorage.getItem('cloud_rate')  || '0.95',
    pitch: localStorage.getItem('cloud_pitch') || '+6%'
  };

  const chkMain = document.getElementById('useCloudTTSChk_main');
  const sel = document.getElementById('cloudVoiceSelect');
  const rateI = document.getElementById('cloudRateInput');
  const pitchI= document.getElementById('cloudPitchInput');
  const saveBtn = document.getElementById('cloudSaveBtn');

  if (chkMain && sel && rateI && pitchI) {
    chkMain.checked = pref.useCloud;
    sel.value = pref.voice;
    rateI.value = pref.rate;
    pitchI.value = pref.pitch;

    chkMain.addEventListener('change', ()=>{
      localStorage.setItem('use_cloud_tts', chkMain.checked ? '1' : '0');
      window.useCloudTTS = chkMain.checked;
    });
    saveBtn.addEventListener('click', ()=>{
      localStorage.setItem('cloud_voice', sel.value);
      localStorage.setItem('cloud_rate', rateI.value);
      localStorage.setItem('cloud_pitch', pitchI.value);
      alert('é›²ç«¯èªéŸ³è¨­å®šå·²ä¿å­˜');
    });
  }

  window.useCloudTTS = localStorage.getItem('use_cloud_tts') === '1';

  const audioCache = new Map();

  function normalizeForSpeech(text){
    if (!text) return '';
    let t = text;
    t = t.replace(/ï¼š/g, 'ï¼š ')
         .replace(/ï¼Œ/g, 'ï¼Œ ')
         .replace(/ã€/g, 'ã€ ')
         .replace(/ã€‚/g, 'ã€‚ ');
    t = t.replace(/\bDUPR\b/gi, 'D U P R')
         .replace(/\bMLP\b/gi, 'M L P')
         .replace(/\bPPA\b/gi, 'P P A');
    t = t.replace(/(^|\s)(\d{1,2})[\-:](\d{1,2})(?=\s|$)/g, (m, p, a, b)=> `${p}${a} æ¯” ${b}`);
    return t.trim();
  }

  function splitSentences(text){
    const parts = [];
    let buf = '';
    for (const ch of text){
      buf += ch;
      if ('ã€‚ï¼ï¼Ÿï¼›'.includes(ch) || buf.length > 180){
        parts.push(buf.trim());
        buf = '';
      }
    }
    if (buf.trim()) parts.push(buf.trim());
    return parts;
  }

  async function speakViaCloudOne(text){
    const payload = {
      text: text,
      voice: localStorage.getItem('cloud_voice') || pref.voice,
      rate:  localStorage.getItem('cloud_rate')  || pref.rate,
      pitch: localStorage.getItem('cloud_pitch') || pref.pitch
    };
    const key = JSON.stringify(payload);
    try{
      let url = audioCache.get(key);
      if (!url){
        const resp = await fetch(server, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        if(!resp.ok) throw new Error('TTS server error');
        const blob = await resp.blob();
        url = URL.createObjectURL(blob);
        audioCache.set(key, url);
      }
      await new Promise((resolve, reject)=>{
        const audio = new Audio(url);
        audio.onended = resolve;
        audio.onerror = ()=> reject(new Error('audio playback error'));
        audio.play().catch(reject);
      });
      return true;
    }catch(e){
      console.warn('Cloud TTS failed for chunk:', e);
      return false;
    }
  }

  async function speakViaCloud(text){
    const norm = normalizeForSpeech(text);
    const chunks = splitSentences(norm);
    for (const c of chunks){
      const ok = await speakViaCloudOne(c);
      if (!ok) return false;
      await new Promise(r=>setTimeout(r, 250));
    }
    return true;
  }
  window.speakViaCloud = speakViaCloud;

  let preferredVoice = null;
  function pickBestVoice(voices) {
    const names = [
      "Google åœ‹èªï¼ˆè‡ºç£ï¼‰","Microsoft HanHan Online (Natural) - Chinese (Taiwan)",
      "Ting-Ting","Mei-Jia","Google ä¸­æ–‡ï¼ˆæ™®é€šè¯ï¼‰",
      "Microsoft Xiaoxiao Online (Natural) - Chinese (Mainland)",
      "Microsoft Aria Online (Natural) - English (United States)","Google US English","Jenny"
    ];
    const byName = voices.find(v => names.includes(v.name));
    return byName || voices[0];
  }
  function initLocalVoices(){
    const load = ()=>{
      const voices = speechSynthesis.getVoices();
      if (voices?.length) preferredVoice = pickBestVoice(voices);
    };
    load(); window.speechSynthesis.onvoiceschanged = load;
  }
  initLocalVoices();

  function speakLocal(text){
    const norm = normalizeForSpeech(text);
    const parts = splitSentences(norm);
    speechSynthesis.cancel();
    for (const p of parts){
      const u = new SpeechSynthesisUtterance(p);
      if (preferredVoice) u.voice = preferredVoice;
      u.rate = 0.97; u.pitch = 1.06; u.volume = 1.0;
      speechSynthesis.speak(u);
    }
  }
  window.speakLocal = speakLocal;

  async function speakUnified(fullText){
    if (window.useCloudTTS){
      const ok = await speakViaCloud(fullText);
      if (ok) return;
      speakLocal(fullText);
    } else {
      speakLocal(fullText);
    }
  }
  window.speakUnified = speakUnified;

  if (!window.speakText_original){
    window.speakText_original = window.speakText || function(t){ speakLocal(t); };
    window.speakText = function(t){ speakUnified(t); };
  }
})();
</script>


<script>
(function(){
  const hook = ()=>{
    if (!window.speak_original){
      window.speak_original = window.speak || function(t){ window.speakLocal ? window.speakLocal(t) : alert(t); };
      window.speak = function(t){ if (window.speakUnified) { window.speakUnified(t); } else { window.speak_original(t); } };
    }
  };
  try{ hook(); }catch(e){}
  window.addEventListener('DOMContentLoaded', hook);
})();
</script>


<script>
// Strong hook for global speak(): always route to cloud-first pipeline
(function(){
  function callUnified(t){
    try {
      // read latest toggle every call
      window.useCloudTTS = (localStorage.getItem('use_cloud_tts') === '1');
      if (typeof window.speakUnified === 'function') {
        return window.speakUnified(t);
      }
    } catch (e) { console.warn(e); }
    // fallback to original or local
    if (typeof window.speak_original === 'function') return window.speak_original(t);
    if (typeof window.speakLocal === 'function') return window.speakLocal(t);
    alert(t);
  }

  // keep reference to the latest assigned original speak
  let _original = (typeof window.speak === 'function') ? window.speak.bind(window) : null;
  window.speak_original = _original || window.speak_original;

  // wrapper returned to callers
  function wrapper(){ return callUnified.apply(this, arguments); }

  try{
    // Intercept future assignments to window.speak
    Object.defineProperty(window, 'speak', {
      configurable: true,
      enumerable: true,
      get(){ return wrapper; },
      set(v){
        // whenever app redefines speak, keep newest as original but continue exposing wrapper
        if (typeof v === 'function') {
          _original = v.bind(window);
          window.speak_original = _original;
        } else {
          _original = null;
        }
      }
    });
  }catch(e){
    console.warn('defineProperty failed, fallback to interval hook', e);
  }

  // watchdog: ensure wrapper stays active even if scripts redefine property descriptor
  setInterval(()=>{
    try{
      const desc = Object.getOwnPropertyDescriptor(window, 'speak');
      if (!desc || (typeof window.speak !== 'function') || window.speak === _original){
        // someone overwrote our getter; re-apply
        Object.defineProperty(window, 'speak', {
          configurable: true, enumerable: true,
          get(){ return wrapper; },
          set(v){
            if (typeof v === 'function') {
              _original = v.bind(window);
              window.speak_original = _original;
            } else {
              _original = null;
            }
          }
        });
      }
    }catch(e){ /* ignore */ }
  }, 500);
})();
</script>


<!-- æµ®å‹• TTS ç‹€æ…‹è§’æ¨™ -->
<div id="ttsFloat" style="position:fixed;left:16px;bottom:16px;z-index:9999;background:#111;color:#fff;padding:6px 10px;border-radius:10px;font-size:12px;opacity:.85;">
  <span id="ttsFloatText">TTS: æº–å‚™ä¸­â€¦</span>
</div>


<script>
(function(){
  function setBadge(mode, voice, detail){
    const badge = document.getElementById('ttsStatusBadge');
    const float = document.getElementById('ttsFloatText');
    const txt = voice ? `TTS: ${mode} Â· ${voice}` : `TTS: ${mode}`;
    if (badge){ badge.textContent = txt; badge.style.background = mode==='Cloud' ? '#DCFCE7' : '#E5E7EB'; badge.style.color = mode==='Cloud' ? '#065F46' : '#111'; }
    if (float){ float.textContent = detail ? `${txt} (${detail})` : txt; }
  }
  window.__setTTSBadge = setBadge;

  async function checkCloudReady(){
    try{
      const server = localStorage.getItem('cloud_tts_server') || 'http://localhost:8787/api/tts';
      const resp = await fetch(server, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ text: 'æ¸¬è©¦', voice: localStorage.getItem('cloud_voice') || 'zh-TW-HsiaoChenNeural', rate: '1.0', pitch: '+0%' })
      });
      return resp.ok;
    }catch(e){ return false; }
  }
  window.__checkCloudReady = checkCloudReady;

  // åˆå§‹ç‹€æ…‹
  setBadge((localStorage.getItem('use_cloud_tts')==='1')?'Cloud':'Local', localStorage.getItem('cloud_voice') || 'æœªè¨­å®š');

  // ç›£çœ‹è¨­å®šè®ŠåŒ–ï¼ˆæ¯ 1s åˆ·æ–°ä¸€æ¬¡ç‹€æ…‹ç‡ˆï¼‰
  setInterval(()=>{
    const mode = (localStorage.getItem('use_cloud_tts')==='1')?'Cloud':'Local';
    const voice = localStorage.getItem('cloud_voice') || 'æœªè¨­å®š';
    setBadge(mode, voice);
  }, 1000);
})();
</script>


<script>
(function(){
  // Wrap speakViaCloud to set status to Cloud on success
  const origCloud = window.speakViaCloud;
  if (typeof origCloud === 'function'){
    window.speakViaCloud = async function(text){
      const ok = await origCloud(text);
      if (ok){
        const voice = localStorage.getItem('cloud_voice') || 'zh-TW-HsiaoChenNeural';
        if (window.__setTTSBadge) window.__setTTSBadge('Cloud', voice);
      }
      return ok;
    }
  }
  // Wrap speakLocal to set status to Local
  const origLocal = window.speakLocal;
  if (typeof origLocal === 'function'){
    window.speakLocal = function(text){
      if (window.__setTTSBadge) window.__setTTSBadge('Local', 'Browser');
      return origLocal(text);
    }
  }
  // Wrap speakUnified to show which path used
  const origUnified = window.speakUnified;
  if (typeof origUnified === 'function'){
    window.speakUnified = async function(text){
      try{
        const wantCloud = (localStorage.getItem('use_cloud_tts') === '1');
        if (wantCloud){
          // å…ˆæ¸¬é›²ç«¯æ˜¯å¦å¯ç”¨
          // ä¸åšå¥åº·æª¢æŸ¥ä»¥å…å»¶é²ï¼›ç›´æ¥å˜—è©¦
          const ok = await window.speakViaCloud(text);
          if (ok) return;
        }
        return window.speakLocal(text);
      } catch(e){
        return window.speakLocal(text);
      }
    }
  }
})();
</script>


<script>
(function(){
  const serverDefault = 'http://localhost:8787/api/tts';
  const serverI = document.getElementById('cloudServerInput');
  const pingBtn = document.getElementById('cloudPingBtn');
  const cloudOnlyChk = document.getElementById('cloudOnlyChk');
  const diagDiv = document.getElementById('cloudDiag');

  function setDiag(msg, ok){
    if (!diagDiv) return;
    diagDiv.style.display = 'block';
    diagDiv.style.borderColor = ok ? '#bbf7d0' : '#fecaca';
    diagDiv.style.background = ok ? '#f0fdf4' : '#fef2f2';
    diagDiv.style.color = ok ? '#14532d' : '#7f1d1d';
    diagDiv.textContent = msg;
  }

  // init server URL
  const savedServer = localStorage.getItem('cloud_tts_server') || serverDefault;
  if (serverI){ serverI.value = savedServer; }
  if (cloudOnlyChk){ cloudOnlyChk.checked = (localStorage.getItem('cloud_only') === '1'); }

  if (serverI){
    serverI.addEventListener('change', ()=>{
      const v = serverI.value.trim() || serverDefault;
      localStorage.setItem('cloud_tts_server', v);
      setDiag('å·²ä¿å­˜ä¼ºæœå™¨ï¼š' + v, true);
    });
  }
  if (cloudOnlyChk){
    cloudOnlyChk.addEventListener('change', ()=>{
      localStorage.setItem('cloud_only', cloudOnlyChk.checked ? '1' : '0');
      setDiag('ã€Œé›²ç«¯åƒ…ç”¨ã€å·²' + (cloudOnlyChk.checked ? 'é–‹å•Ÿ' : 'é—œé–‰'), true);
    });
  }

  if (pingBtn){
    pingBtn.addEventListener('click', async ()=>{
      const url = (serverI && serverI.value.trim()) || serverDefault;
      localStorage.setItem('cloud_tts_server', url);
      try{
        const resp = await fetch(url, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ text:'ç³»çµ±æ¸¬è©¦', voice: localStorage.getItem('cloud_voice') || 'zh-TW-HsiaoChenNeural', rate:'1.0', pitch:'+0%' })
        });
        if (!resp.ok){
          const txt = await resp.text();
          setDiag('Cloud æ¸¬è©¦å¤±æ•—ï¼šHTTP ' + resp.status + ' ' + txt.slice(0,200), false);
          if (window.__setTTSBadge) window.__setTTSBadge('Local', 'Browser', 'Cloud æ¸¬è©¦å¤±æ•—');
          return;
        }
        const blob = await resp.blob();
        const urlBlob = URL.createObjectURL(blob);
        const audio = new Audio(urlBlob);
        await audio.play();
        setDiag('Cloud æ¸¬è©¦æˆåŠŸï¼šå·²æˆåŠŸç”¢ç”Ÿä¸¦æ’­æ”¾é›²ç«¯èªéŸ³ã€‚', true);
        if (window.__setTTSBadge) window.__setTTSBadge('Cloud', localStorage.getItem('cloud_voice') || 'HsiaoChen', 'æ¸¬è©¦æˆåŠŸ');
      }catch(e){
        setDiag('Cloud æ¸¬è©¦éŒ¯èª¤ï¼š' + (e && e.message ? e.message : e), false);
        if (window.__setTTSBadge) window.__setTTSBadge('Local', 'Browser', 'Cloud æ¸¬è©¦éŒ¯èª¤');
      }
    });
  }

  // Patch speakViaCloudOne to use server from input/localStorage and detailed diagnostics
  if (typeof window.speakViaCloudOne === 'function'){
    const original = window.speakViaCloudOne;
    window.speakViaCloudOne = async function(text){
      const server = (serverI && serverI.value.trim()) || localStorage.getItem('cloud_tts_server') || serverDefault;
      try{
        const payload = {
          text: text,
          voice: localStorage.getItem('cloud_voice') || 'zh-TW-HsiaoChenNeural',
          rate:  localStorage.getItem('cloud_rate')  || '0.95',
          pitch: localStorage.getItem('cloud_pitch') || '+6%'
        };
        const key = JSON.stringify(payload);
        // ç›´å‘¼åŸå‡½å¼å¯èƒ½æœªä½¿ç”¨æœ€æ–° serverï¼Œå› æ­¤åœ¨é€™è£¡ä»¥ fetch ç›´æ¥å¯¦ä½œï¼Œé¿å…èˆŠé‚è¼¯
        const resp = await fetch(server, {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        if (!resp.ok){
          const txt = await resp.text();
          setDiag('é›²ç«¯è«‹æ±‚å¤±æ•—ï¼šHTTP ' + resp.status + ' ' + txt.slice(0,200), false);
          return false;
        }
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        await new Promise((resolve, reject)=>{
          const audio = new Audio(url);
          audio.onended = resolve;
          audio.onerror = ()=> reject(new Error('audio æ’­æ”¾éŒ¯èª¤'));
          audio.play().catch(reject);
        });
        if (window.__setTTSBadge) window.__setTTSBadge('Cloud', payload.voice);
        return true;
      }catch(e){
        setDiag('é›²ç«¯è«‹æ±‚éŒ¯èª¤ï¼š' + (e && e.message ? e.message : e), false);
        return false;
      }
    }
  }

  // Modify unified speak to respect "cloud_only" for debugging
  if (typeof window.speakUnified === 'function'){
    const origUnified = window.speakUnified;
    window.speakUnified = async function(text){
      try{
        const wantCloud = (localStorage.getItem('use_cloud_tts') === '1');
        const cloudOnly = (localStorage.getItem('cloud_only') === '1');
        if (wantCloud){
          const ok = await window.speakViaCloud(text);
          if (ok) return;
          if (cloudOnly){
            if (window.__setTTSBadge) window.__setTTSBadge('Local', 'Browser', 'é›²ç«¯å¤±æ•—ï¼ˆåƒ…ç”¨æ¨¡å¼ï¼Œä¸æ’­æœ¬æ©Ÿï¼‰');
            return; // do not fallback
          }
        }
        return window.speakLocal(text);
      } catch(e){
        if (window.__setTTSBadge) window.__setTTSBadge('Local', 'Browser', 'ä¾‹å¤–ï¼š' + e.message);
        return window.speakLocal(text);
      }
    }
  }
})();
</script>


<script>
// ---- Robust TTS controller: single-flight, cancelable, with diagnostics ----
(function(){
  const serverDefault = 'http://localhost:8787/api/tts';
  const getServer = ()=> localStorage.getItem('cloud_tts_server') || serverDefault;

  // global controller
  const TTS = window.TTS = window.TTS || {};
  TTS._current = null;           // { type: 'cloud'|'local', audios: [HTMLAudioElement], canceled: bool }
  TTS._playing = false;

  function diag(msg, ok){
    const diagDiv = document.getElementById('cloudDiag');
    if (!diagDiv) return;
    diagDiv.style.display = 'block';
    diagDiv.style.borderColor = ok ? '#bbf7d0' : '#fecaca';
    diagDiv.style.background = ok ? '#f0fdf4' : '#fef2f2';
    diagDiv.style.color = ok ? '#14532d' : '#7f1d1d';
    diagDiv.textContent = msg;
  }
  function setBadge(mode, voice, detail){
    if (window.__setTTSBadge) window.__setTTSBadge(mode, voice, detail);
  }

  TTS.cancel = function(reason){
    try{
      const cur = TTS._current;
      if (!cur) return;
      cur.canceled = true;
      // stop any audio
      if (cur.audios) for (const a of cur.audios){ try{ a.pause(); a.src=''; }catch(e){} }
      // stop local
      try{ window.speechSynthesis && window.speechSynthesis.cancel(); }catch(e){}
      TTS._current = null;
      TTS._playing = false;
      setBadge('Local', 'Browser', reason || 'å·²ä¸­æ­¢');
    }catch(e){}
  };

  async function playCloudChunks(chunks){
    const voice = localStorage.getItem('cloud_voice') || 'zh-TW-HsiaoChenNeural';
    const rate  = localStorage.getItem('cloud_rate')  || '0.95';
    const pitch = localStorage.getItem('cloud_pitch') || '+6%';
    const server = getServer();

    const audios = [];
    TTS._current = { type:'cloud', audios, canceled:false };
    for (let i=0; i<chunks.length; i++){
      if (TTS._current?.canceled) throw new Error('æ’­æ”¾å·²å–æ¶ˆ');
      const text = chunks[i];
      try{
        const resp = await fetch(server, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ text, voice, rate, pitch })
        });
        if (!resp.ok){
          const txt = await resp.text();
          diag(`é›²ç«¯å¤±æ•—ï¼ˆç¬¬ ${i+1}/${chunks.length} æ®µï¼‰ï¼šHTTP ${resp.status} ${txt.slice(0,200)}`, false);
          throw new Error('Cloud HTTP '+resp.status);
        }
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        audios.push(audio);
        await new Promise((resolve, reject)=>{
          if (TTS._current?.canceled) return reject(new Error('æ’­æ”¾å·²å–æ¶ˆ'));
          audio.onended = resolve;
          audio.onerror = ()=> reject(new Error('audio æ’­æ”¾éŒ¯èª¤'));
          audio.play().catch(reject);
        });
        URL.revokeObjectURL(url);
        await new Promise(r=>setTimeout(r, 250));
      }catch(e){
        throw e;
      }
    }
  }

  // Wrap existing helpers with controller
  const normalizeForSpeech = window.normalizeForSpeech || function(t){ return (t||'').toString(); };
  const splitSentences = window.splitSentences || function(t){ return [t]; };

  // Replace speakViaCloud to single-flight + detailed errors
  const origSpeakViaCloud = window.speakViaCloud;
  window.speakViaCloud = async function(text){
    try{
      TTS.cancel('åˆ‡æ›æ–°æ’­å ±');
    }catch(e){}
    const norm = normalizeForSpeech(text);
    const chunks = splitSentences(norm).filter(Boolean).map(s=>s.trim()).filter(Boolean);
    if (!chunks.length){ diag('æ²’æœ‰å¯æ’­å ±çš„å…§å®¹ã€‚', false); return false; }
    // ç‰‡æ®µé•·åº¦éé•·åˆ‡å‰²ä¿éšª
    const safeChunks = [];
    for (const c of chunks){
      if (c.length <= 400) { safeChunks.push(c); continue; }
      for (let i=0;i<c.length;i+=400) safeChunks.push(c.slice(i, i+400));
    }
    try{
      TTS._playing = true;
      setBadge('Cloud', localStorage.getItem('cloud_voice') || 'HsiaoChen', 'æº–å‚™æ’­æ”¾');
      await playCloudChunks(safeChunks);
      setBadge('Cloud', localStorage.getItem('cloud_voice') || 'HsiaoChen', 'å®Œæˆ');
      return true;
    }catch(e){
      diag('é›²ç«¯éŒ¯èª¤ï¼š' + (e && e.message ? e.message : e), false);
      setBadge('Local', 'Browser', 'é›²ç«¯å¤±æ•—');
      return false;
    }finally{
      TTS._playing = false;
    }
  };

  // Replace speakLocal to single-flight
  const origSpeakLocal = window.speakLocal;
  window.speakLocal = function(text){
    try{ TTS.cancel('åˆ‡æ›è‡³æœ¬æ©Ÿ'); }catch(e){}
    const norm = normalizeForSpeech(text);
    const parts = splitSentences(norm);
    try{ window.speechSynthesis && window.speechSynthesis.cancel(); }catch(e){}
    for (const p of parts){
      const u = new SpeechSynthesisUtterance(p);
      if (window.preferredVoice) u.voice = window.preferredVoice;
      u.rate = 0.97; u.pitch = 1.06; u.volume = 1.0;
      window.speechSynthesis.speak(u);
    }
    setBadge('Local', 'Browser', 'æ’­æ”¾ä¸­');
  };

  // Replace unified to check "cloud_only" and avoid silent failure
  const origUnified = window.speakUnified;
  window.speakUnified = async function(text){
    const wantCloud = (localStorage.getItem('use_cloud_tts') === '1');
    const cloudOnly = (localStorage.getItem('cloud_only') === '1');
    if (wantCloud){
      const ok = await window.speakViaCloud(text);
      if (ok) return;
      if (cloudOnly){
        // åªç”¨é›²ç«¯ï¼šé›²ç«¯å¤±æ•—ç›´æ¥è¿”å›ï¼ˆä¸æ’­æ”¾æœ¬æ©Ÿï¼‰ï¼Œä»¥ä¾¿ä½¿ç”¨è€…å¯Ÿè¦º
        return;
      }
    }
    return window.speakLocal(text);
  };

  // Provide global stop button hook if needed
  window.stopTTS = ()=> TTS.cancel('æ‰‹å‹•åœæ­¢');
})();
</script>


<script>
(function(){
  function toPercent(s, kind){
    if (!s) return (kind==='rate'?'95%':'+6%');
    s = String(s).trim();
    if (s.endsWith('%')) return s;
    const n = Number(s);
    if (!isNaN(n)){
      if (kind==='rate'){
        if (n <= 2) return Math.round(n*100) + '%';
        return Math.round(n) + '%';
      } else {
        if (Math.abs(n) <= 2) return (n>=0?'+':'') + Math.round(n*100) + '%';
        return (n>=0?'+':'') + Math.round(n) + '%';
      }
    }
    return (kind==='rate'?'95%':'+6%');
  }
  const save = document.getElementById('cloudSaveBtn');
  if (save){
    save.addEventListener('click', ()=>{
      const rI = document.getElementById('cloudRateInput');
      const pI = document.getElementById('cloudPitchInput');
      if (rI){ rI.value = toPercent(rI.value, 'rate'); localStorage.setItem('cloud_rate', rI.value); }
      if (pI){ pI.value = toPercent(pI.value, 'pitch'); localStorage.setItem('cloud_pitch', pI.value); }
    });
  }
})();
</script>


<script>
(function(){
  function toSignedPercent(s){
    if (!s) return "0%";
    s = String(s).trim();
    if (/^[+-]?\d+(?:\.\d+)?%$/.test(s)) {
      if (s.startsWith('+') || s.startsWith('-')) return s;
      const n = parseFloat(s);
      const delta = Math.round(n - 100);
      return (delta>=0?'+':'') + delta + '%';
    }
    const n = Number(s);
    if (!isNaN(n)){
      if (Math.abs(n) <= 2){
        const delta = Math.round((n - 1) * 100);
        return (delta>=0?'+':'') + delta + '%';
      } else {
        const delta = Math.round(n - 100);
        return (delta>=0?'+':'') + delta + '%';
      }
    }
    return "0%";
  }

  const rateI  = document.getElementById('cloudRateInput');
  const pitchI = document.getElementById('cloudPitchInput');
  const save   = document.getElementById('cloudSaveBtn');
  const minus  = document.getElementById('rateMinusBtn');
  const plus   = document.getElementById('ratePlusBtn');

  function clampPercent(s){
    const m = s.match(/^([+-]?)(\d+)%$/);
    if (!m) return s;
    let sign = m[1] || '';
    let val = parseInt(m[2], 10);
    if (val > 90 && sign === '-') val = 90; // floor -90%
    if (val > 200 && sign !== '-') val = 200; // cap +200%
    return (sign || '+') + val + '%';
  }

  function bump(delta){
    let cur = toSignedPercent(rateI.value || '0%');
    const m = cur.match(/^([+-]?)(\d+)%$/);
    let val = 0;
    if (m){
      const sign = m[1]==='-'?-1:1;
      val = sign * parseInt(m[2],10);
    }
    val = Math.max(-90, Math.min(200, val + delta));
    const res = (val>=0?'+':'') + val + '%';
    rateI.value = res;
    localStorage.setItem('cloud_rate', res);
  }

  if (minus) minus.addEventListener('click', ()=> bump(-5));
  if (plus)  plus.addEventListener('click',  ()=> bump(+5));

  if (save){
    save.addEventListener('click', ()=>{
      const r = clampPercent(toSignedPercent(rateI.value));
      rateI.value = r;
      localStorage.setItem('cloud_rate', r);
      const p = pitchI.value || '+6%';
      localStorage.setItem('cloud_pitch', p);
      alert('é›²ç«¯èªéŸ³è¨­å®šå·²ä¿å­˜');
    });
  }
})();
</script>


<script>
// ---- Robust audio playback to avoid false negatives ----
(function(){
  // Utility: play a Blob as audio robustly
  async function playBlob(blob){
    const url = URL.createObjectURL(blob);
    return await new Promise((resolve, reject)=>{
      const audio = new Audio();
      audio.preload = 'auto';
      let ended = false;
      let started = false;
      const cleanup = ()=>{
        try{
          audio.onended = null;
          audio.onerror = null;
          audio.onplaying = null;
          audio.oncanplaythrough = null;
          audio.src = '';
        }catch(e){}
        try{ URL.revokeObjectURL(url); }catch(e){}
      };
      audio.onplaying = ()=>{ started = true; };
      audio.onended = ()=>{ ended = true; cleanup(); resolve(true); };
      audio.onerror = ()=>{
        // Safari/Chromium æœ‰æ™‚æœƒåœ¨å·²é–‹å§‹æ’­æ”¾å¾Œä»è§¸ç™¼ errorï¼›è‹¥å·²é–‹å§‹æˆ–æœ‰é€²åº¦ï¼Œå°±è¦–ç‚ºæˆåŠŸ
        if (ended || started || (audio.currentTime && audio.currentTime > 0)){
          cleanup(); resolve(true); return;
        }
        cleanup(); reject(new Error('audio æ’­æ”¾éŒ¯èª¤'));
      };
      audio.src = url;
      const p = audio.play();
      if (p && typeof p.catch === 'function'){
        p.catch((err)=>{
          // æŸäº›ç€è¦½å™¨æœƒå…ˆæ‹’çµ• promiseï¼Œä½†å¯¦éš›ä»å¯æ’­æ”¾ï¼›å»¶é²æª¢æŸ¥ä¸€æ¬¡
          setTimeout(()=>{
            if (ended || started || (audio.currentTime && audio.currentTime > 0)){
              cleanup(); resolve(true);
            } else {
              cleanup(); reject(err || new Error('audio æ’­æ”¾éŒ¯èª¤'));
            }
          }, 350);
        });
      }
    });
  }
  window.__playBlobRobust = playBlob;

  // If our cloud player exists, patch it to use robust playback
  if (typeof window.speakViaCloud === 'function'){
    // Try to detect our single-flight implementation pieces
    // Replace internal playCloudChunks if exists
    if (typeof window.TTS === 'object'){
      // monkey patch helper inside speakViaCloud by wrapping fetch->blob->play
      const origSpeakViaCloud = window.speakViaCloud;
      window.speakViaCloud = async function(text){
        // Run original; if it reports failure due to "audio æ’­æ”¾éŒ¯èª¤", retry with robust path
        try{
          const ok = await origSpeakViaCloud(text);
          if (ok) return true;
        }catch(e){ /* fallthrough to robust */ }
        // Fallback robust path: stream chunks again using robust player
        try{
          const normalizeForSpeech = window.normalizeForSpeech || (t=>t||'');
          const splitSentences = window.splitSentences || (t=>[t]);
          const norm = normalizeForSpeech(text);
          const chunks = splitSentences(norm).filter(Boolean).map(s=>s.trim()).filter(Boolean);
          if (!chunks.length) return false;
          const voice = localStorage.getItem('cloud_voice') || 'zh-TW-HsiaoChenNeural';
          const rate  = localStorage.getItem('cloud_rate')  || '0%';
          const pitch = localStorage.getItem('cloud_pitch') || '+6%';
          const server = localStorage.getItem('cloud_tts_server') || 'http://localhost:8787/api/tts';
          for (let i=0;i<chunks.length;i++){
            const resp = await fetch(server, {
              method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ text: chunks[i], voice, rate, pitch })
            });
            if (!resp.ok){
              const txt = await resp.text();
              if (window.__setTTSBadge) window.__setTTSBadge('Local','Browser','HTTP '+resp.status);
              return false;
            }
            const blob = await resp.blob();
            await playBlob(blob);
            await new Promise(r=>setTimeout(r, 200));
          }
          if (window.__setTTSBadge) window.__setTTSBadge('Cloud', voice, 'å®Œæˆ');
          return true;
        }catch(e){
          if (window.__setTTSBadge) window.__setTTSBadge('Local','Browser','robust æ’­æ”¾å¤±æ•—');
          return false;
        }
      }
    }
  }
})();
</script>

</body>
</html>